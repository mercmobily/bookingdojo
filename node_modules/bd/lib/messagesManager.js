var
  dummy

, hotplate =  require('hotplate')
, declare = require( 'simpledeclare' )
, async = require('async')
, debug = require('debug')('bd')

, emailaddresses = require( 'email-addresses')
//, htmlToText = require('html-to-text') // Moved to sms-plivo

, hotCoreJsonRestStores = hotplate.require('hotCoreJsonRestStores')
, hotCoreMultiHome = hotplate.require('hotCoreMultiHome')
, hotCoreSharedCode = hotplate.require('hotCoreSharedCode')
, hotCoreStoreRegistry = hotplate.require( 'hotCoreStoreRegistry' )
, hotCoreServerLogger = hotplate.require( 'hotCoreServerLogger' )
, logger = hotCoreServerLogger
, hotCoreTransport = hotplate.require( 'hotCoreTransport')
;

var logLine = hotCoreTransport.transportLayerFunctions.logLine;

hotplate.hotEvents.on( 'stores', 'bd', hotplate.cachable( function( done ){

  var stores = {};

  var MultiHomePermsMixin = hotCoreMultiHome.MultiHomeBasicPermissionsMixin;
  var PrivateUserDataMixin = hotCoreJsonRestStores.PrivateUserDataPermissionsMixin;

  hotCoreJsonRestStores.get( function( err, s ){
    if( err ) return done( err );

    var HotStore = s.HotStore;
    var HotSchema = s.HotSchema;
    var BasicDbStore = s.BasicDbStore;
    var BasicSchema = s.BasicSchema;

    var WorkspacesMessagesToLookup = declare( [ BasicDbStore ], {

      schema: new BasicSchema({
        id                : { type: 'id', searchable: true },
        added             : { type: 'date', searchable: true, default: function() { return new Date() } },
        workspaceId       : { type: 'id', searchable: true },
        contactId         : { type: 'id', searchable: true },
        to                : { type: 'string', required: true,  notEmpty: true, trim: 50, searchable: true },
        type              : { type: 'string', searchable: true, required: true, notEmpty: true, trim: 5 },
      }),

      storeName:  'workspacesMessagesToLookup',
      idProperty: 'id',
    });
    stores.workspacesMessagesToLookup = new WorkspacesMessagesToLookup();


    var WorkspacesMessages = declare( [ HotStore, MultiHomePermsMixin ],  {

      schema: new HotSchema({
        added          : { type: 'date', searchable: true,  protected: true, default: function() { return new Date() } },
        incoming       : { type: 'boolean', required: false, protected: true, default: false },
   
        messageId      : { type: 'id', required: false, protected: true, searchable: true },
        fromContactId  : { type: 'id', required: false },

        //textPreview    : { type: 'string', searchable: false, protected: true, default: '', trim: 1024 },
     
        // These two fields will determine if the fields are editable or not after saving
        computedFrom      : { type: 'boolean', searchable: true, default: false },
        computedTo        : { type: 'boolean', searchable: true, default: false },

        // Computed strings to make as few queries as possible when displaying the list of messages
        fromString        : { type: 'string', searchable: false, protected: true },
        toString          : { type: 'string', searchable: false, protected: true },

        // DoNotSave fields (they are in Messages)
        systemMessage     : { type: 'boolean', required: false, doNotSave: true }, 
        to                : { type: 'string', required: false, doNotSave: true, notEmpty: false, trim: 16000 },
        type              : { type: 'string', required: true, doNotSave: true, notEmpty: true, trim: 5, validator: function( o, v, fieldName ){  if( v !== 'email' && v !== 'sms' ) return "Type must be 'sms' or 'email' " } },

        subject           : { type: 'string', searchable: true, doNotSave: true, required: false, default: '',notEmpty: false, trim: 1024 },
        bodyText          : { type: 'string', searchable: true, doNotSave: true, required: false, default: '', notEmpty: true, trim: 256000 },
        bodyHtml          : { type: 'string', searchable: true, doNotSave: true, required: false, default: '', notEmpty: true, trim: 256000 },

      }),


      onlineSearchSchema: new HotSchema({
        incoming          : { type: 'boolean' },
        type              : { type: 'string', trim: 5 },

        // Contact search (from, to, either)
        fromContactId     : { type: 'id' },
        toContactId       : { type: 'id', searchOptions: [
          { field: 'workspacesMessagesTo.id', type: 'eq', condition: 'and'  },
        ]},
        contactId: { type: 'id', searchOptions: [
          { field: 'workspacesMessagesTo.contactId', type: 'eq', condition: 'or'  },
          { field: 'fromContactId',  type: 'eq', condition: 'or'  },
        ] },
      
      }),

      nested: [
        {
          layer: 'workspacesMessagesTo',
          join: { 'workspaceMessageId': 'id' },
          type: 'multiple'
        },

        /*
        {
          layer: 'workspacesMessagesAttachments',
          join: { 'workspaceMessageId': 'id' },
          type: 'multiple'
        },
        */

        {
          layer: 'workspacesContacts',
          join: { 'id': 'fromContactId' },
          type: 'lookup',
          parentField: 'fromContactId',          
        },

        {
          layer: 'messages',
          join: { 'id': 'messageId' },
          type: 'lookup',
          parentField: 'messageId',          
        },

      ],

      storeName:  'workspacesMessages',

      publicURL: '/workspaces/:workspaceId/messages/:id',
      hotExpose: true,

      handlePost: true,
      handleGet: true,
      handleGetQuery: true,

      alwaysRefreshOnChange: true,

      defaultSort: { 'added': -1 },
      sortableFields: [ 'added' ],
		  
      prepareBeforeSend: function( request, method, p, done ){

				hotCoreStoreRegistry.getAllStores( function( err, storeRegistry){
					if( err ) return done( err );

					hotCoreSharedCode.getAllSharedFunctions( function( err, sharedFunctions ){
						if( err ) return done( err );

						//debug("In order to generate computedTo, query workspacesMessagesTo with:", { workspaceId: p.doc.workspaceId, messageId: p.doc.messageId } );

						//debug( "request: ", request )
						storeRegistry.workspacesMessagesTo.apiGetQuery( { filters: { workspaceId: p.doc.workspaceId, messageId: p.doc.messageId } }, function( err, tos ){
							if( err ) return done( err );

							//debug("Tos is:", tos );

							var result = [];
							async.eachSeries(

								tos,

								function( workspaceTo, cb ){
									//debug("Considering: ", workspaceTo );

									if( workspaceTo.contactId ){

										storeRegistry.workspacesContacts.apiGet( workspaceTo.contactId, function( err, contact ){
											if( err ) return done( err );

											result.push( sharedFunctions.renderContactName( contact ) );

											if( workspaceTo.messageToId ){
												cb( null );

											} else {
												cb( null );
											}

										});
									} else  if( workspaceTo.messageToId ){
										storeRegistry.messagesTo.apiGet( workspaceTo.messagesToId, function( err, messageTo ){
											if( err ) return done( err );
											result.push( messageTo.to );

											cb( null );
										});
									} else {

										// Log the problem
									}
								},

								function( err ){
									if( err ) return done( err );

									p.doc.computedTo = result.join( ', ' );
								  done( null, p.doc );
								}
							);							
						});
		      });
				});
			},

      // To understand what is going on, read the following comments for
      // postCheckPermissions() and  postDbOperation(), which are executed one after the other
      // When adding to this store, the only fields that are expected are:
      // to, type, subject, body.
      // However, NONE of them will actually be stored. This is what actually happens:
      // * incoming     : set to false
      // * fromContactId: set as the contact linked to the currently logged in user
      // * messageId    : first create an entry in transport.messages with from, type, subject, body
      //                  (with "from" taken from workspace config, and the rest from the optional fields)
      //                  and then set messageId as the transport's messageId
      // The field "to" is used to  get the list of IDs, and then add respective entries in transport:
      // * messagesTo
      // * workspacesMessagesTo.
      //
      // This is how it all happens:

      _selectFromContactId: function( request, done ){

		    hotCoreStoreRegistry.getAllStores( function( err, storeRegistry){

		    	debug("in _selectFromContactId, deciding who fromContactId will be" );

	        // REMOTE request 
	        if( request.remote ){

		    	  debug("It's a remote request. Runnng a query on workspacesContacts looking for the request's userId. Query:", { ranges: { limit: 1 }, filters: { userId: request._req.session.userId } } );

	          storeRegistry.workspacesContacts.apiGetQuery( { ranges: { limit: 1 }, filters: { userId: request._req.session.userId } }, function( err, docs ){
	            if( err ) return done( err );

	            debug( "Matching contacts:: ", docs )

	            // Paranoid check in case the linked contact wasn't found.
	            if( docs.length === 0 ) return cb( new Error("Could not find contact linked to user while sending message"));

							debug( "Returning record ID: ", docs[ 0 ].id )

	            // This is the contact linked to the user
	            return done( null, docs[ 0 ].id );
	          });

	        // LOCAL request: use request.body.fromContactId
	        } else {
		    	  debug("It's an API request: returning ", request.body.fromContactId );
	          return done( null, request.body.fromContactId );
	        }
				});	       
      },


      postCheckPermissions: function( request, method, p, done ){

        var self = this;
        
        
      	// Don't do ANYTHING if it's not adding a new element (post), or it's incoming
        // (If the message is incoming, it means that it has actually already arrived and
        // it's already in the hotTransport tables. So, there is no need to do any of this)
				if( method !== 'post' || request.body.incoming ) return done( null );

				debug("In postCheckPermissions, request.body is: ", request.body );

        hotCoreStoreRegistry.getAllStores( function( err, storeRegistry ){
          if( err ) return done( err );

          var body = request.body;

          // To field cannot be empty
          if( body.to == '' ){
            return done( new self.UnprocessableEntityError( { errors: [ { field: 'to', message: 'Recipient must be specified' } ]  } ) );
    			}

          // ***********************
          // STEP 1: Work out fromContactId, from request (remote call) or passed parameter (API)
          // ***********************
          debug( "Working out fromContactId")
          self._selectFromContactId( request, function( err, fromContactId ){
            if( err ) return done( err );


	          debug( "Linking this message to: (fromContactId)", fromContactId );

            // ***********************
            // STEP 2: Add the message to transport.messages, using type, subject, body  
            // ***********************
            // Note: 'body' is always HTML from BookingDojo. I make an email that includes
            // both HTML and TEXT by using htmlToText.
            var o = {
              incoming: false,
              type: body.type,
              from: '' // Empty to start with, determined later as sending-time
            };
            if( body.subject ) o.subject = body.subject;
            if( body.bodyText ) o.bodyText = body.bodyText;
            if( body.bodyHtml ) o.bodyHtml = body.bodyHtml;

            //bodyHtml: body.body,
            //bodyText: htmlToText.fromString( body.body, { wordwrap: 130 } ),

            debug("Adding record to stores.message:", o );
            storeRegistry.messages.apiPost( o, function( err, res ){
              if( err ) return done( err );

              // ********************************************
              // STEP 3: Enrich workspacesMessages.body with the right info
              // ********************************************              
              // THe "right info" is:
              // * Newly obtained messageId
              // * Incoming set to false
              // * Previoulsy obtained contactId, if there
              // ********************************************

              // The body's messageId will match the record we just created
              body.messageId = res.id;

              // It's an incoming message by default
              body.incoming = false;

              // If fromContactId was found, then set it
              if( fromContactId ) body.fromContactId = fromContactId;

              debug( "Body is:", body );

              // ********************************************
              // STEP 4: Work out which table the IDs passed in `to` are from
              // ********************************************              
              // They could be from:
              // * workspacesContactsPhoneNumbers
              // * workspacesContactsEmails
              // Depending on the message type. Saving it into workspacesContactsXXX
              // ********************************************

              // The workspacesContactsXXX will depend on the type: the IDs might be a bunch of email IDs
              // or a bunch of phone number IDs
              var workspacesContactsXXX;
              switch( request.body.type ) {
                case 'sms'  : workspacesContactsXXX = storeRegistry.workspacesContactsPhoneNumbers; break;
                case 'email': workspacesContactsXXX = storeRegistry.workspacesContactsEmails; break;
              }

              debug( "workspacesContactsXXX is:", workspacesContactsXXX.storeName );

              // *****************************************************************
              // STEP 5: Carry some information to the next hook
              // *****************************************************************
              // The information carried on to the next hook is:
              // * request.body.to          -- needed by next call, and about to get zapped
              //                               because of the doNotSave option
              // * request.body.type        -- Ditto
              // * workspacesContactsXXX    -- The right store, just worked out
              // * storeRegistry.messagesTo -- The messagesTo store
              //
              // The messagesTo store is passed for convenience: this way I
              // won't need to call hotCoreStoreRegistry.getAllStores again
              // ******************************************************************

              request.kept = { 
                to: request.body.to, // will get zapped
                type: request.body.type, // will get zapped
                fromContactId: fromContactId, // will get zapped
                workspacesContactsXXX: workspacesContactsXXX, // will be used by next call
                storeRegistry: storeRegistry,
              };

              debug( "information kept for next hook: ",require('util').inspect( request.kept, { depth: 0 } ) );

              done( null );
            });
          });
        });
	    }, 

      _makeupTo: function( type, record ){
        switch( type ){
          case 'email': return record.email;
          case 'sms'  : return record.dialCode + record.number;
        }
      },


      // ******************************************************************
      // At this point, workspacesMessages and transport.message have
      // the message. It's now a matter of working on the `to` field
      // and fill workspacesMessagesTo and transport.messagesTo.
      // So, there we go...
      // ******************************************************************
      postDbOperation: function( request, method, p, done ){

				
      	// Don't do ANYTHING if it's not adding a new element (post), or it's incoming
        // (If the message is incoming, it means that it has actually already arrived and
        // it's already in the hotTransport tables. So, there is no need to do any of this)
				if( method !== 'post' || request.body.incoming ) return done( null );

				debug("In postDbOperation, request.body is: ", request.body );

        var self = this;

        // ******************************************************************
        // For each item in `to`...
        // ******************************************************************

        var toArray = request.kept.to.split( ',' );
        debug("toArray is: ", toArray );
        async.eachSeries( 

          toArray,

          function( id, cb ){

            // *****************************************************************
            // STEP 6: Lookup the full to: information given the ID.
            // *****************************************************************
            // Note: this will use the right store, depending on the message type
            // ******************************************************************

            debug( "Processing: ", toArray );

            request.kept.workspacesContactsXXX.apiGet( id, function( err, info ){
              if( err ){
              	debug("Didn't process id as it couldn't be resolved, id and error:", id, err )
								logLine( null, null, 2, "Error processing passed ID", err );
              	return cb( null );
              }

              // *****************************************************************
              // STEP 7: Add the message information to transport.messageTo
              // *****************************************************************

              // Add item to messagesTo
              var o = {
                messageId: request.body.messageId,
                to: self._makeupTo( request.kept.type, info ),
                status: 'todeliver',
                failedAttempts: 0,
              };
              debug("request.kept.fromContactId is:", request.kept.fromContactId );
           		if( request.kept.fromContactId ){

                debug("Adding request.kept.fromContactId to o.appData" );
                o.appData = { senderContactId: request.kept.fromContactId };
           		}
                
              debug( "About to write to messageTo: ", o );
              request.kept.storeRegistry.messagesTo.apiPost( o, function( err, messageTo ){
                if( err ) return cb( err );

                // *****************************************************************
                // STEP 8: Add the message information to workspacesMessagesTo
                // *****************************************************************

                var o = {
                  workspaceId: request.body.workspaceId,
                  workspaceMessageId: p.fullDoc.id,
                  contactId: info.contactId,      
                  messageToId: messageTo.id,
                  messageId: request.body.messageId

                };
                debug( "About to write to workspacesMessagesTo: ", o );
                request.kept.storeRegistry.workspacesMessagesTo.apiPost( o, function( err, workspaceMessageTo ){
                  if( err ) return cb( err );

                  // *****************************************************************
                  // STEP 9: Try and add an entry to workspacesMessagesToLookup
                  // *****************************************************************

                  // Try and add the entry to the lookup table, so that incoming messages
                  // can be matched to a contact when they come back (useful for SMSes that don't
                  // allow setting of subject or status)
                  var f = { filters: { workspaceId: request.body.workspaceId, to: messageTo.to, type: request.kept.type } };
                  debug( "Matching incoming message in workspacesMessagesToLookup, filter: ", f );
                  request.kept.storeRegistry.workspacesMessagesToLookup.apiGetQuery( f, function( err, docs ){
                 
                    if( err ){
                      logger.log( { 
                        system: true, 
                        logLevel: 3, 
                        message: "Could not look for entries in workspacesMessagesToLookup",
                        data: { lookup: lookup },
                        error: err,
                        workspaceId: request.body.workspaceId 
                      });
                      return;
                    }

                    var lookup;
                    debug("The query returned: ", docs );

                    // Entry already there: just re-save it with updated date
                    if( docs.length ){
                      lookup = docs[ 0 ];
                      lookup.added = new Date();
                      debug("Lookup entry: with updated date: ", lookup );
                      request.kept.storeRegistry.workspacesMessagesToLookup.apiPut( null, lookup, function( err ){
                        if( err ){
                          logger.log( { 
                            system: true, 
                            logLevel: 3, 
                            message: "Could not update entry in workspacesMessagesToLookup",
                            data: { lookup: lookup },
                            error: err,
                            workspaceId: request.body.workspaceId
                          });
                        }
                        return;
                      });

                    // Entry not there: save a new one with all of the info
                    } else {

                      debug("No entres in lookup table, creating one" );

                      lookup = {
                        added      : new Date(),
                        workspaceId: request.body.workspaceId,
                        contactId  : request.kept.fromContactId,
                        to         : messageTo.to,
                        type       : request.kept.type
                      };
                      
                      debug("Lookup entry created:", lookup );

                      request.kept.storeRegistry.workspacesMessagesToLookup.apiPost( lookup, function( err ){
                        if( err ){
                          logger.log( { 
                            system: true, 
                            logLevel: 3, 
                            message: "Could not create entry in workspacesMessagesToLookup",
                            data: { lookup: lookup },
                            error: err, 
                          });
                        }
                      });                      
                    }
                  
                  })

                  // This happens regardless of the block above manipulating workspacesMessagesToLookup
                  // which, in case of errors, will just logger.log(...)
                  cb( null );

                });    

              });

            });            
          },

          function( err ){
            if( err ) return done( err );

            done( null );
          }
        );
      },       


    });
    stores.workspacesMessages = new WorkspacesMessages();


    var WorkspacesMessagesTo = declare( [ HotStore, MultiHomePermsMixin ],  {

    	// TODO: Make a check, at least EITHER messageToId OR contactId NEED to be set
      schema: new HotSchema({

        messageToId       : { type: 'id', required: false, searchable: true },        
        contactId         : { type: 'id', required: false, searchable: true },

        messageId         : { type: 'id', required: true, searchable: true }, // NN
      }),

      onlineSearchSchema: new HotSchema({
      }),

      storeName:  'workspacesMessagesTo',

      publicURL: '/workspaces/:workspaceId/messages/:workspaceMessageId/to/:id',
      hotExpose: true,

      handleGet: true,
      handleGetQuery: true,
      position: true,
      
    });
    stores.workspacesMessagesTo = new WorkspacesMessagesTo();


    /*
    var WorkspacesMessagesAttachments = declare( [ HotStore, MultiHomePermsMixin ],  {

      schema: new HotSchema({

        messageAttachmentId: { type: 'id', required: true, searchable: true },        
        messageId          : { type: 'id', required: true, searchable: true }, // NN
      }),

      onlineSearchSchema: new HotSchema({
      }),

      storeName:  'workspacesMessagesAttachments',

      publicURL: '/workspaces/:workspaceId/messages/:workspaceMessageId/attachments/:id',
      hotExpose: true,

      handleGet: true,
      handleGetQuery: true,
      
    });
    stores.workspacesMessagesAttachments = new WorkspacesMessagesAttachments();
    */


    done( null, stores );
  });

}));

hotplate.hotEvents.on( 'augmentMessageDeliveryLog', 'bd', hotplate.cachable( function( o, done ){


	debug("Trying to work out who this log entry belongs to:", o );

	if( o.workspaceId ){
		debug("workspaceId already set, that's it");
		return done( null );
	}
	
	// If there is no messageId, there is no point in even talking about it.
	if( ! o.messageId ){
		debug("There is no messageId: giving up working out who this logLine belongs to");
		return done( null );
	}

	// If there is no trace of workspaceId, it will need to be looked up by
	// workspacesMessages. A lookup on that messageId will do the job.
  hotCoreStoreRegistry.getAllStores( function( err, storeRegistry){
    if( err ) return done( err );
	
		debug("Looking up message in workspacesMessages to workout workspaceId")
    storeRegistry.workspacesMessages.apiGetQuery( { filters: { messageId: o.messageId } }, function( err, workspaceMessage){
      if( err ) return done( err );

     	if( workspaceMessage.length !== 1 ){
     		debug( "workspaceMessage is the wrong length, giving up", workspaceMessage.length );
     		return cb( null );
     	}

     	// Actually assign the value
     	o.workspaceId = workspaceMessage[ 0 ].workspaceId;

      debug( "Looked up! This log line will belong to:", o.workspaceId );
    });
	});
}));


hotplate.hotEvents.on( 'allTransportConfig', 'bd', hotplate.cachable( function( transport, done ){

  hotCoreStoreRegistry.getAllStores( function( err, storeRegistry){
    if( err ) return done( err );

    switch( transport ){

      case 'email-default':
        // TODO: Filter by ACTIVE workspaces
        storeRegistry.workspacesEmailConfig.apiGetQuery( {}, function( err, workspaceEmailConfigRecords ){
          if( err ) return done( err );

          return done( null, workspaceEmailConfigRecords );
        });
      break;

      // They will return one entry per registered phone number, where each one is:
      //  { fullNumber,  numberType, account, token } );
      // This is exactly the same structure returned by transportConfig, but as an array
         
      case 'sms-plivo':
      case 'sms-twilio':

        var provider = transport === 'sms-twilio' ? 'twilio' : 'plivo';
        var result = [];

        if( provider == 'twilio' ){
            var s = storeRegistry.plivoConfig;
        } else if( provider == 'plivo') {
            var s = storeRegistry.plivoConfig; // TODO: add Plivo in GUI
        } else {
          return done( new Error("Unrecognised provider type: ", provider ))
        }

        s.apiGetQuery( {}, function( err, smsGatewayConfig ){
          if( err ) return done( err );

          var l = smsGatewayConfig.length;
          if( l === 0 ) return done( null, [] );
          if( l > 1 ) return done( new Error("More than 1 config found for " + transport ));

          var config = smsGatewayConfig[ 0 ];

          storeRegistry.phoneNumbers.apiGetQuery( { filters: { provider: provider } }, function( err, phoneNumbers ){
            if( err ) return done( err );

            phoneNumbers.forEach( function( item ){
              result.push( { fullNumber: item.fullNumber, numberType: item.type, account: config.account, token: config.token } );
            });

            return done( null, result );
          });
        });

      break;
    }
  });

}));


hotplate.hotEvents.on( 'transportConfig', function( messageTo, done ){
  var type = messageTo._children.messageId.type;
  var messageId = messageTo.messageId;

  hotCoreStoreRegistry.getAllStores( function( err, storeRegistry){
    if( err ) return done( err );

    // I need to lookup the message as I need to figure out the workspaceId
    storeRegistry.workspacesMessages.apiGetQuery( { sort: { added: 1 }, filters: { messageId: messageId } }, function( err, workspacesMessages){
      if( err ) return done( err );

      var l = workspacesMessages.length;

      if( l === 0 ) cb( new Error("Could not lookup workspacesMessage from messageId!"));
      if( l > 1 ) cb( new Error("Found more than 1 workspacesMessage from one messageId!"));

      var workspaceMessage = workspacesMessages[ 0 ];
      var workspaceId = workspaceMessage.workspaceId;

      switch( type ){

        case 'email':

          storeRegistry.workspacesEmailConfig.apiGet( workspaceId, function( err, workspaceEmailConfig ){
            if( err ) return done( err );

             done( null, { transport: 'email-default', config: workspaceEmailConfig } );
          });
        

        break;

        case 'sms':

          storeRegistry.workspacesSmsConfig.apiGet( workspaceId, function( err, workspaceSms ){

            if( err ) return done( err );

            if( ! workspaceSms.phoneNumberId ) return done( new Error( "No SMS configuration found for ths workspace") );

            var phoneNumber = workspaceSms._children.phoneNumberId;
            var fullNumber =  phoneNumber.fullNumber;
            var type = phoneNumber.type;

            if( phoneNumber.provider == 'twilio' ){
              var s = storeRegistry.plivoConfig;
              var t = 'sms-twilio';
            } else if( phoneNumber.provider == 'plivo') {
              var s = storeRegistry.plivoConfig; // TODO: add Plivo in GUI
              var t = 'sms-plivo';
            } else {
              return done( new Error("Unrecognised provider type: ", phoneNumber.provider ))
            }

            s.apiGetQuery( {}, function( err, smsGatewayConfig ){
              if( err ) return done( err );

              var l = smsGatewayConfig.length;
              if( l === 0 ) return done( new Error("Config missing for " + t ));
              if( l > 1 ) return done( new Error("More than 1 config found for " + t ));

              var config = smsGatewayConfig[ 0 ];

              done( null, { transport: t, config: { fullNumber: fullNumber, numberType: type, account: config.account, token: config.token } } );
            });
          });

        break;
      };

    });
  });

});



// Before sending, it will add to the subject so that it can work out whe the answer is
// to when the usersends a reply back
hotplate.hotEvents.on( 'transportManipulateBeforeSend', function( transport, messageTo, config, done ){

	debug("Manipulating messageTo before sending:", messageTo );
	
	if( transport !== 'email-default' ){
  	debug("Quitting as it's not email-default", messageTo );

		return done( null );
	}

  debug("appData is: ", messageTo.appData );
	if( messageTo.appData && messageTo.appData.senderContactId ){
	  messageTo._children.messageId.subject += " [C:" + messageTo.appData.senderContactId + "]";
	}
	done( null );

});

// Before saving, it will take the trailing [C:443] out so that it's clear on the database.
// However, it will save what *was* there in appData so that transportMessageFetched can use it
hotplate.hotEvents.on( 'transportManipulateMessageBeforeSave', function( transport, message, config, done ){

  debug("In bd hook of transportManipulateMessageBeforeSave");

  // Only deal with email-default transport
  if( transport != 'email-default'){
  	debug("bd hook aborted as it's not an email");
    return done( null );
  }

  // Look for the ID in the email
  var match = message.subject.match(/\[C:(.*?)\]$/);
  var id;

  // If the subject has "This is the subject [C:7837492]", then make the match
  match && ( id = match[ 1 ] );
  debug("Match in subject is: ", match );
  debug("ID is: ", id );
  if( id ){
    message.appData = message.appData || {};
    message.appData.idInSubject = id;
  }
  debug( "message.appData is now:", message.appData );

  // Take out the ID from the subject, so that we store something clean onto the DB
  message.subject = message.subject.replace(/ *\[C:(.*?)\]$/,'');

  // That's it
  done( null );
});


// A message was fetched: add it to the workspaceMessages and workspacesMessagesTo tables

hotplate.hotEvents.on( 'transportMessageFetched', 'bd', function( transport, config, messageRecord, messageToRecord, cb ){

  debug("Message received, transport and config and message: ", transport, config, require('util').inspect( messageRecord, { depth: Infinity} ) );

  hotCoreStoreRegistry.getAllStores( function( err, storeRegistry){
    if( err ) return cb( err );

    // It's an email.
    // We know which workspace the message belongs to (config.workspaceId), but not which user, which
    // will be worked out from the subject

    function workoutMessagesToContactId( cb ){

      var id;

      debug("Looking for an ID in ", messageRecord );

      // Assign `id` if it's in appData
      if( messageRecord.appData && messageRecord.appData.idInSubject ) id = messageRecord.appData.idInSubject;

      if( ! id ){
        debug("No ID, end of the story" );
        return cb( null );
      }

      debug("About to look for ID in workspacesContacts...", id );

      // There is an ID: try and get it
      // TODO: check if a bad ID can cause err to be set (if ast fails)
      storeRegistry.workspacesContacts.apiGetQuery( { ranges: { limit: 1 }, filters: { workspaceId: config.workspaceId, id: id } }, function( err, docs ){

        debug("Call to DB resulted in: ", err, docs );
        if( err ) return cb( err );

        // Nothing was returned: ID not found, end of story
        if( docs.length === 0 ) return cb( null );

        debug("Returning something! ", docs[ 0 ] .id );

        // Something was found!
        return cb( null, docs[ 0 ].id );

        cb( null );
      });
    }

    function workoutMessagesFromContactId( cb ){

      var from = messageRecord.from
      debug("Email is from: ", from );

      var email = emailaddresses.parseOneAddress( from );

      debug("Email parsed: ", email );

      // No email address, no search
      if( email === null || email == '' ) return cb( null );

      email = email.address;
      debug("Email (just address): ", email );

      // There is an ID: try and get it
      // TODO: check if a bad ID can cause err to be set (if cast fails)
      debug("Running a search. Filter:", { ranges: { limit: 1 }, filters: { workspaceId: config.workspaceId, email: email } } );

      storeRegistry.workspacesContactsEmailsBase.apiGetQuery( { ranges: { limit: 1 }, filters: { workspaceId: config.workspaceId, email: email } }, function( err, docs ){

        debug("Call to DB for emails resulted in: ", err, docs );
        if( err ) return cb( err );

        // Nothing was returned: ID not found, end of story
        if( docs.length === 0 ) return cb( null );

        debug("Returning something! This is the contactId for the email address:", docs[ 0 ].contactId );

        // Something was found!
        return cb( null, docs[ 0 ].contactId );

      });
    }

    // Add to workspacesMessage and then workspacesMessagesTo with right contactId

    if( messageRecord.type == 'email' ){

      workoutMessagesToContactId( function( err, messagesToContactId ){
        debug( "messagesToContactId is: ", messagesToContactId )

        workoutMessagesFromContactId( function( err, messagesFromContactId ){
          debug( "messagesFromContactId is: ", messagesFromContactId )

          // Make up the object. Note that fromContactId might be set
          // or not, depending on whether something was found
          var wm = {
            workspaceId: config.workspaceId,
            incoming: true,
            type: messageRecord.type,
            messageId: messageRecord.id,
            computedTo: true,
            computedFrom: true,
            to: '',
          };
          if( messagesFromContactId ) wm.fromContactId = messagesFromContactId;

          debug( "About to store:" );
          debug( "Message:", wm );

          storeRegistry.workspacesMessages.apiPost( wm, function( err, workspaceMessage ){
            if( err ) return cb( err );

            // Make up the messagesTo object. Note that contactId might be set
            // or not, depending on whether something was found
            var wmt = {
              workspaceMessageId: workspaceMessage.id,
              workspaceId: config.workspaceId,
              messageToId: messageRecord._children.messagesTo[ 0 ].id,
              messageId: messageRecord.id,
            }
            if( messagesToContactId ) wmt.contactId = messagesToContactId;

            debug( "About to store:" );
            debug( "MessageTo:", wmt );

            storeRegistry.workspacesMessagesTo.apiPost( wmt, function( err ){
              if( err ) {

							  storeRegistry.workspacesMessages.dbLayer.delete( { conditions: { and: [ { field: 'id', type: 'is', value: workspaceMessage.id } ] } }, { multi: true }, function( err ){
			  					logLine( config, null, null, 3, "Error deleting entry from workspacesMessages (doing so because adding to workspacesMessagesTo failed!)", err );

							  });
							  return cb( err );
							}

              // All good, end of story!
              cb( null );

            });
          });

        });
      });


    } else if( messageRecord.type == 'sms' ){

      debug("It's an SMS!");

      storeRegistry.phoneNumbers.apiGetQuery({ ranges: { limit: 1 }, filters: { fullNumber: messageToRecord.to } }, function( err, docs ){
        if( err ) return cb( err );

        debug( "The number " + messageToRecord.to + " was looked up in phoneNumbers, result: ", docs );

        // No phone numbers found. This is strange, since it means that an SMS subsystem delivered a
        // message destinated to a phone number we don't manage.
        // Note that an error is created just for this. Since no req is passed, it won't get logged
        // against a workspace
        // 
        if( docs.length == 0 ){
          var err = new Error("Lookup of fullNumber in PhoneNumbers failed");
          err.data = { config: config, messageRecord: messageRecord, messageToRecord: messageToRecord };
          return cb( err );
        }

        var phoneNumber = docs[ 0 ];
        debug("Phone number looked up, there is a result!", phoneNumber );

        // Find out what workspace, contactId this message is for.
        // This is tricky as a number could be 'private' to a workspace, or
        // shared amongst many.
        // In ANY case, the system needs to query workspacesMessageToLookup as
        // it still needs to figure out which contactId to assign.
        // (And, eventually, which booking)
        // Note that who the message is *from* can only be done later, on a
        // workspace-by-workspace basis

        // Make up the filter: if it's a private number, will just filter by workspace/fullNumber...
        var filter;
        if( config.numberType == 'private' ){
          filter = { to: messageToRecord.to, workspaceId: config.workspaceId };// WAS: config.ownedByWorkspaceId
        // ...whereas if it's shared, will filter just by fullNumber (potentially returning n records)
        } else if( config.numberType == 'shared' ){
          filter = { to: messageRecord.from }
        } else {
          logger.log( { system: true, logLevel: 2, message: "Received an SMS for an 'available' number, won't forward it to any workspace... ", data: { config: config, messageRecord: messageRecord, messageToRecord: messageToRecord } } );
          return done( null );
        }
        filter.type = 'sms'; // Type is always sms
        debug("Phone number is " + config.numberType + ", filter is: ", filter );

        storeRegistry.workspacesMessagesToLookup.apiGetQuery( { filters: filter, sort: { added: 1 } }, function( err, docs ){

          if( err ) return cb( err );

          debug("Lookup table contaned: ", docs );

          if( docs.length === 0 ) {
            debug("Nothing found in workspacesMessagesToLookup")
            if( config.numberType == 'private' ){
              debug("numberType is private. Calling nextStep with: ", [ { workspaceId: config.workspaceId } ]);
              nextStep( [ { workspaceId: config.workspaceId } ] )
            } else {
              debug("numberType is NOT prvate. Callng nextStep with empty array")
              nextStep( [] );
            }
          } else {
            debug("Items found in workspacesMessagesToLookup, making up array for nextStep");
            var a = [];
            docs.forEach( function( doc ) { 
              a.push( { workspaceId: doc.workspaceId, messagesToContactId: doc.contactId });
            });
            debug("About to call nextStep with:", a );
            nextStep( a );
          }

        });

        // At this point, wids will be an array of all workspaces this message is for.
        // All workspaces will receive it. There is a slim chance more than 1 will get it: in
        // this case, a system log will also be issued
        function nextStep( lookups ){

          debug( "nextStep is dealing with workspaces: ", lookups );

          async.eachSeries(
            lookups,
            function( lookupEntry, cb){
              debug( "Dealing with lookup entry", lookupEntry );

              debug( "Searching into workspacesContactsPhoneNumbers: ", { fullNumber: messageRecord.from, workspaceId: lookupEntry.workspaceId } );

              storeRegistry.workspacesContactsPhoneNumbers.apiGetQuery({ filters: { fullNumber: messageRecord.from, workspaceId: lookupEntry.workspaceId } }, function( err, docs ){

                if( err ) return cb( err );

                debug("Found following contacts this message could be from: ", docs );
                if( docs.length != 0 ){

                  debug("Some contacts found, picking the first one! " );
                  var messagesFromContactId = docs[ 0 ].contactId;
                }

                var messagesToContactId = lookupEntry.messagesToContactId;
                var workspaceId = lookupEntry.workspaceId;

                debug("messagesFromContactId: ", messagesFromContactId );
                debug("messagesToContactId: ", messagesToContactId );
                debug("workspaceId: ", workspaceId );

                // Make up the object. Note that fromContactId might be set
                // or not, depending on whether something was found
                var wm = {
                  workspaceId: workspaceId,
                  incoming: true,
                  type: messageRecord.type,
                  messageId: messageRecord.id,
                  computedFrom: true,
                  computedTo: true,
                };
                if( messagesFromContactId ) wm.fromContactId = messagesFromContactId;

                debug( "About to store:" );
                debug( "Message:", wm );

                storeRegistry.workspacesMessages.apiPost( wm, function( err, workspaceMessage ){
                  if( err ) return cb( err );

                  // Make up the messagesTo object. Note that contactId might be set
                  // or not, depending on whether something was found
                  var wmt = {
                    workspaceMessageId: workspaceMessage.id,
                    workspaceId: workspaceId,
                    messageToId: messageRecord._children.messagesTo[ 0 ].id,
                    messageId: messageRecord.id,
                  }
                  if( messagesToContactId ) wmt.contactId = messagesToContactId;

                  debug( "About to store:" );
                  debug( "MessageTo:", wmt );

                  storeRegistry.workspacesMessagesTo.apiPost( wmt, function( err ){
                    if( err ){

  										storeRegistry.workspacesMessages.dbLayer.delete( { conditions: { and: [ { field: 'id', type: 'is', value: workspaceMessage.id  } ] } }, { multi: true }, function( err ){
  											logLine( config, null, null, 3, "Error deleting entry from workspacesMessages (doing so because adding to workspacesMessagesTo failed!)", err );
  										});

                    	return cb( err );
                    } 

                    // All good, end of story!
                    cb( null );
                  });
                });

              });


            },

            // End of the cycle. Note that an error above MUST be propagated,
            // so that the SMS processor will get an HTTP error and will try and
            // redeliver the message
            function( err ){
            	if( err ) return cb( err );

            	cb( null );
            }


          ); // End of foreach of lookup entries 
        } // End of nextStep

      });

    } else {
      logger.log( { system: true, logLevel: 3, message: "Received a transportMessageFetched event of unknown type: " + messageRecord.type } );
      cb( null );
    }

  });
});

