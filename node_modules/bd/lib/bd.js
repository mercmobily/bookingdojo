var
  dummy

, hotplate =  require('hotplate')
, path = require('path')
, async = require('async')

, declare = require( 'simpledeclare' )

, hotCoreJsonRestStores = hotplate.require('hotCoreJsonRestStores')
, hotCoreMultiHome = hotplate.require('hotCoreMultiHome')
, hotCoreStoreRegistry = hotplate.require( 'hotCoreStoreRegistry' )

, JsonRestStores = require( 'jsonreststores' )
;

app = hotplate.app;

JsonRestStores.artificialDelay = 500;

hotplate.hotEvents.on( 'allTransportConfig', 'bd', function( transport, done ){

  hotCoreStoreRegistry.getAllStores( function( err, storeRegistry){
    if( err ) return done( err );

    switch( transport ){

      case 'email-default':
        // TODO: Filter by ACTIVE workspaces
        storeRegistry.workspacesEmailConfig.apiGetQuery( {}, function( err, workspaceEmailConfigRecords ){
          if( err ) return done( err );

          return done( null, workspaceEmailConfigRecords );
        });
      break;

      // They will return one entry per registered phone number, where each one is:
      //  { fullNumber,  numberType, account, token } );
      // This is exactly the same structure returned by transportConfig, but as an array
         
      case 'sms-plivo':
      case 'sms-twilio':

        var provider = transport === 'sms-twilio' ? 'twilio' : 'plivo';
        var result = [];

        if( provider == 'twilio' ){
            var s = storeRegistry.plivoConfig;
        } else if( provider == 'plivo') {
            var s = storeRegistry.plivoConfig; // TODO: add Plivo in GUI
        } else {
          return done( new Error("Unrecognised provider type: ", provider ))
        }

        s.apiGetQuery( {}, function( err, smsGatewayConfig ){
          if( err ) return done( err );

          var l = smsGatewayConfig.length;
          if( l === 0 ) cb( new Error("Config missing for " + t ));
          if( l > 1 ) cb( new Error("More than 1 config found for " + t ));

          var config = smsGatewayConfig[ 0 ];

          storeRegistry.phoneNumbers.apiGetQuery( { filters: { provider: provider } }, function( err, phoneNumbers ){
            if( err ) return done( err );

            phoneNumbers.forEach( function( item ){
              result.push( { fullNumber: item.fullNumber, numberType: item.type, account: config.account, token: config.token } );
            });

            return done( null, result );
          });
        });

      break;
    }
  });

});


hotplate.hotEvents.on( 'transportConfig', function( messageTo, done ){
  var type = messageTo._children.messageId.type;
  var messageId = messageTo.messageId;

  hotCoreStoreRegistry.getAllStores( function( err, storeRegistry){
    if( err ) return done( err );

    // I need to lookup the message as I need to figure out the workspaceId
    storeRegistry.workspacesMessages.apiGetQuery( { sort: { added: 1 }, filters: { messageId: messageId } }, function( err, workspacesMessages){
      if( err ) return done( err );

      var l = workspacesMessages.length;

      if( l === 0 ) cb( new Error("Could not lookup workspacesMessage from messageId!"));
      if( l > 1 ) cb( new Error("Found more than 1 workspacesMessage from one messageId!"));

      var workspaceMessage = workspacesMessages[ 0 ];
      var workspaceId = workspaceMessage.workspaceId;

      switch( type ){

        case 'email':

          // Now that I have the workspace ID, I can get the workspace's email configuration
          // I will get both SMTP and IMAP and return them both.
          // Eventually they might become just one store

          storeRegistry.workspacesEmailConfig.apiGet( workspaceId, function( err, workspaceEmailConfig ){
            if( err ) return done( err );

             done( null, { transport: 'email-default', config: workspaceEmailConfig } );
          });
        

        break;

        case 'sms':

          storeRegistry.workspacesSmsConfig.apiGet( workspaceId, function( err, workspaceSms ){
            if( err ) return done( err );

            var phoneNumber = workspaceSms._children.phoneNumberId;
            var fullNumber =  phoneNumber.fullNumber;
            var type = phoneNumber.type;

            if( phoneNumber.provider == 'twilio' ){
              var s = storeRegistry.plivoConfig;
              var t = 'sms-twilio';
            } else if( phoneNumber.provider == 'plivo') {
              var s = storeRegistry.plivoConfig; // TODO: add Plivo in GUI
              var t = 'sms-plivo';
            } else {
              return done( new Error("Unrecognised provider type: ", phoneNumber.provider ))
            }


            s.apiGetQuery( {}, function( err, smsGatewayConfig ){
              if( err ) return done( err );

              var l = smsGatewayConfig.length;
              if( l === 0 ) cb( new Error("Config missing for " + t ));
              if( l > 1 ) cb( new Error("More than 1 config found for " + t ));

              var config = smsGatewayConfig[ 0 ];

              done( null, { transport: t, config: { fullNumber: fullNumber, numberType: type, account: config.account, token: config.token } } );
            });
          });

        break;
      };

    });
  });

});




hotplate.hotEvents.on( 'run', 'bd', hotplate.cachable( function( done ){


  hotCoreStoreRegistry.getAllStores( function( err, storeRegistry ){
    if( err ) return done( err );

    // Redefine postEverything() for workspaceUsersBase, workspacesUsers, usersWorkspaces
    storeRegistry.workspacesUsersBase.redefineMethod( 'postEverything', function( request, method, p, cb ){
      this.inheritedAsync( storeRegistry.workspacesUsersBase.postEverything, arguments, function( err ){
        if( err ) return done( err );

        // Only do anything for 'post'
        if( method !== 'post' ) return cb( null );
        storeRegistry.workspacesContacts.apiPost( { userId: p.doc.userId, workspaceId: p.doc.workspaceId }, {}, cb );
      });
    });
    storeRegistry.workspacesUsers.redefineMethod( 'postEverything', function( request, method, p, cb ){
      this.inheritedAsync( storeRegistry.workspacesUsers.postEverything, arguments, function( err ){
        if( err ) return done( err );

        // Only do anything for 'post'
        if( method !== 'post' ) return cb( null );
        storeRegistry.workspacesContacts.apiPost( { userId: p.doc.userId, workspaceId: p.doc.workspaceId }, {}, cb );
      });
    });
    storeRegistry.usersWorkspaces.redefineMethod( 'postEverything', function( request, method, p, cb ){
      this.inheritedAsync( storeRegistry.usersWorkspaces.postEverything, arguments, function( err ){
        if( err ) return done( err );

        // Only do anything for 'post'
        if( method !== 'post' ) return cb( null );
        storeRegistry.workspacesContacts.apiPost( { userId: p.doc.userId, workspaceId: p.doc.workspaceId }, {}, cb );
      });
    })



    // Simply activate path to client files
    hotplate.hotEvents.on( 'transportMessageFetched', 'bd', function( config, fullMessageRecord, cb ){

      console.log("I AM IN BOOKINGDOJO: ", config, require('util').inspect( fullMessageRecord, { depth: Infinity} ) );

      hotCoreStoreRegistry.getAllStores( function( err, storeRegistry){
        if( err ) return cb( err );






        console.log("DEBUG *******************: ", config.workspaceId );
        // Add the message to the workspacesMessages table
        storeRegistry.workspacesMessages.apiPost({
          workspaceId: config.workspaceId,
          incoming: true,
          type: fullMessageRecord.type,
          messageId: fullMessageRecord.id,
        }, function( err, workspaceMessage ){
          if( err ) { console.log( err ); return cb( err ); } 

          // Add a record to workspacesMessagesTo table; note that while this is
          // "billable" and it's linked to a messageId (which is an incoming system-generated
          // message), there is no contactId linked as it's not yet known who this message was
          // actually for
          storeRegistry.workspacesMessagesTo.apiPost({
            workspaceMessageId: workspaceMessage.id,
            workspaceId: config.workspaceId,
            messageToId: fullMessageRecord._children.messagesTo[ 0 ].id,
            messageId: fullMessageRecord.id,
            billable: true,
          }, function( err, workspaceMessage ){
            if( err ) { console.log( err ); return cb( err ); } 


            /*
              Split logic into two:

              EMAIL:
              You know which workspace the message belongs to (config.workspaceId), but not which user.
              * On way out, add something to the subject "Hello there [323123]"
              * On way in, match subject string with id, and look for the first one matching
              * Add workspacesMessagesTo with right contactId

              SMS:
                * Lookup phone number in PhoneNumbers
                  * If exclusive for workspace:
                     - wsArray[ wid ] = true;
                  * If shared:
                     - wsArray[ wid ] = true for every workspace that sent a message to that number in the last week
                     - if Object.keys( wsArray) > 1 log level 3 with warning to admin
                * For each wsArray:
                  - add message to workspacesMessages
                  - run assignContactsToWorkspaceMessage()

            */


            // TODO: add records to workspacesMessagesTo, each entry with a contactId,
            // based on the subject (email), info (sms).


            cb( null );
          });
        });
      });
    });


    // End of Hotplate's 'run' hook
    done( null );
  });
}));


hotplate.hotEvents.on( 'stores', 'bd', hotplate.cachable( function( done ){

  var stores = {};

  var MultiHomePermsMixin = hotCoreMultiHome.MultiHomeBasicPermissionsMixin;
  var PrivateUserDataMixin = hotCoreJsonRestStores.PrivateUserDataPermissionsMixin;

  hotCoreJsonRestStores.get( function( err, s ){
    if( err ) return done( err );

    var HotStore = s.HotStore;
    var HotSchema = s.HotSchema;
    var BasicDbStore = s.BasicDbStore;
    var BasicSchema = s.BasicSchema;

    var UsersInfo = declare( [ HotStore, MultiHomePermsMixin, PrivateUserDataMixin ], {

      schema: new HotSchema({
        email       :  { type: 'string', required: true, default: "youremail@example.com", notEmpty: true, sharedValidator: 'email', trim: 255, min: 4 },
        //surname     :  { type: 'string', required: true, default: "Your surname", notEmpty: true, trim: 10 },
        //name        :  { type: 'string', required: true, default: "Your name", notEmpty: true, trim: 50 },
      }),

      onlineSearchSchema: new HotSchema({
        email     : { type: 'string' },
        //surname   : { type: 'string' },
        //name      : { type: 'string' },
      }),

      handlePut: true,
      handleGet: true,

      storeName:  'usersInfo',

      publicURL: '/config/users/:userId',
      hotExpose: true,
      configStore: { userId: true },
    });
    stores.usersInfo = new UsersInfo();


    var UsersInterests = declare( [ HotStore, MultiHomePermsMixin, PrivateUserDataMixin ], {

      schema: new HotSchema({
        name          : { type: 'string', required: true, trim: 35, searchable: true },
      }),

      onlineSearchSchema: new HotSchema({
      }),

      storeName: 'usersInterests',

      publicURL: '/config/users/:userId/interests/:id',
      hotExpose: true,
      configStore: { userId: true },

      defaultNewToStart: true,

      position: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      
    });
    stores.usersInterests = new UsersInterests();


    var WorkspacesInfo = declare( [ HotStore, MultiHomePermsMixin ], {

      schema: new HotSchema({
        longName: { 
          type: 'string', 
          required: true, 
          default: "Workspace's long name", 
          notEmpty: true, 
          trim: 35, 
          searchable: true
        },
        tag: { 
          type: 'string', 
          required: true, 
          default: "Workspace's tag line",
          notEmpty: true,
          trim: 70,
          searchable: true
        },
        statsUse: {
          type: 'id',
          required: false,
          notEmpty: false
        },
        countryDialCodeDefault: { 
          type: 'string',
          required: false,
          notEmpty: true,
          trim: 4,
          min: 1,
          sharedValidator: 'countryDialCode'
        },
      }),

      onlineSearchSchema: new HotSchema({
      }),

      storeName:  'workspacesInfo',

      publicURL: '/config/workspacesInfo/:workspaceId',
      hotExpose: true,
      configStore: { workspaceId: true },

      handlePut: true,
      handleGet: true,
    });
    stores.workspacesInfo = new WorkspacesInfo();


    var WorkspacesUsersInfo = declare( [ HotStore, MultiHomePermsMixin, PrivateUserDataMixin ], {

      schema: new HotSchema({
        setting1          : { type: 'string',  required: true, default: 'Default 1', notEmpty: true,  trim: 35 },
        orderByNameDefault: { type: 'boolean', required: true, default: true },
        notificationsEmailAddress  : { type: 'id',  required: false },
      }),

      onlineSearchSchema: new HotSchema({
      }),

      storeName: 'workspacesUsersInfo',

      publicURL: '/config/workspaces/:workspaceId/users/:userId',
      hotExpose: true,
      configStore: { workspaceId: true, userId: true },

      handlePut: true,
      handleGet: true,

      nested: [
        {
          layer: 'workspacesContacts',
          join: { userId: 'userId' },
          type: 'multiple',
        }
      ],

    });
    stores.workspacesUsersInfo = new WorkspacesUsersInfo();


    var WorkspacesUsersActivities = declare( [ HotStore, MultiHomePermsMixin, PrivateUserDataMixin ], {

      schema: new HotSchema({
        name        : { type: 'string', notEmpty: true, trim: 50, searchable: true },
      }),
      onlineSearchSchema: new HotSchema({
      }),

      storeName:  'workspacesUsersActivities',

      publicURL: '/config/workspaces/:workspaceId/users/:userId/activities/:id',
      hotExpose: true,
      configStore: { workspaceId: true, userId: true },

      position: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      
    });
    stores.workspacesUsersActivities = new( WorkspacesUsersActivities );

    var WorkspacesContactsCategories = declare( [ HotStore, MultiHomePermsMixin ], {

      schema: new HotSchema({
        name         : { type: 'string', notEmpty: true, trim: 50, searchable: true },
        enabled      : { type: 'boolean', default: true }
      }),

      enabledField: 'enabled',

      onlineSearchSchema: new HotSchema({
        enabled      : { type: 'boolean', default: true }
      }),

      storeName:  'workspacesContactsCategories',

      publicURL: '/config/workspaces/:workspaceId/contactsCategories/:id',
      hotExpose: true,
      configStore: { workspaceId: true },

      position: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
    });
    stores.workspacesContactsCategories = new WorkspacesContactsCategories();

    // Root-level store
    var StatsUses = declare( [ HotStore ], {

      schema: new HotSchema({
        name         : { type: 'string', notEmpty: true, trim: 50, searchable: true },
      }),

      onlineSearchSchema: new HotSchema({
      }),

      storeName:  'statsUses',

      publicURL: '/statsUses/:id',
      hotExpose: true,
      configStore: { },

      position: true,

      hotGlobalBroadcast: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      
    });
    stores.statsUses = new StatsUses();


  

    var WorkspacesContacts = declare( [ HotStore, MultiHomePermsMixin ],  {

      schema: new HotSchema({
        firstName         : { type: 'string', notEmpty: true, required: false, trim: 50, searchable: true },
        middleName        : { type: 'string', required: false, trim: 50, searchable: true },
        lastName          : { type: 'string', required: false, trim: 50, searchable: true },
        dateOfBirth       : { type: 'date',   required: false, searchable: true },
        isCompany         : { type: 'boolean',required: false, searchable: true },
        contactCategory   : { type: 'id',     required: false, notEmpty: false, searchable: true },

        isStarred         : { type: 'boolean',protected: true, required: false, default: false, searchable: true },

        /* Main info */
        mainAddressId     : { type: 'id', protected: true, required: false },
        mainPhoneNumberId : { type: 'id', protected: true, required: false },
        mainEmailId       : { type: 'id', protected: true, required: false },
        
        /* Linked user */
        userId      : { type: 'id', protected: true, required: false },
      }),


      onlineSearchSchema: new HotSchema({
        firstName      : { type: 'string' },
        middleName     : { type: 'string' },
        lastName       : { type: 'string' },
        dateOfBirth    : { type: 'date' },
        isCompany      : { type: 'boolean' },
        contactCategory: { type: 'id' },
        isStarred      : { type: 'boolean' },

        searchAll      : { type: 'string', trim: 20, searchable: true, searchOptions: [
          { field: 'firstName', type: 'startsWith', condition: 'or' },
          { field: 'lastName',  type: 'startsWith', condition: 'or' },
          { field: 'workspacesContactsEmails.email',  type: 'startsWith', condition: 'or' },
          { field: 'workspacesContactsAddresses.street',  type: 'startsWith', condition: 'or' }
        ] },

      }),

      sortableFields: [ 'firstName', 'lastName' ],
      defaultSort: { 'lastName': 1 },

      storeName:  'workspacesContacts',

      publicURL: '/workspaces/:workspaceId/contacts/:id',
      hotExpose: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      
      nested: [

        {
          layer: 'workspacesContactsEmails',
          join: { 'id' : 'mainEmailId' },
          type: 'lookup',
          parentField: 'mainEmailId',
        },

        {
          layer: 'workspacesContactsAddresses',
          join: { 'id' : 'mainAddressId' },
          type: 'lookup',
          parentField: 'mainAddressId',
        },

        {
          layer: 'workspacesContactsPhoneNumbers',
          join: { 'id' : 'mainPhoneNumberId' },
          type: 'lookup',
          parentField: 'mainPhoneNumberId',
        },

        {
          layer: 'workspacesContactsAddresses',
          join: { 'contactId': 'id' },
          type: 'multiple'
        },

        {
          layer: 'workspacesContactsEmails',
          join: { 'contactId': 'id' },
          type: 'multiple'
        },

        {
          layer: 'workspacesContactsPhoneNumbers',
          join: { 'contactId': 'id' },
          type: 'multiple'
        },



      ],
      children: true,


    });
    stores.workspacesContacts = new WorkspacesContacts();


    var WorkspacesContactsIsStarred = declare( [ WorkspacesContacts, JsonRestStores.OneFieldStoreMixin ], {
      storeName: 'workspacesContactsIsStarred',
      collectionName: 'workspacesContacts',
      publicURL: '/workspaces/:workspaceId/contacts/isStarred/:id',

      piggyField: 'isStarred',
      hotExpose: true,  
    });
    stores.workspacesContactsIsStarred = new WorkspacesContactsIsStarred();


    var UpdateFirstParentMixin = declare( null,  {

      firstParentStoreField: null,

      _setMain: function( request, cb ){

        cb( null );

        var self = this;

        self.apiGetQuery( { ranges: { limit: 1 }, filters: { contactId: request.params.contactId } }, function( err, docs ){
          if( err ) return cb( err );

          // Get the document. If it's not set, there is no "main" email addres
          var doc = docs[ 0 ];
          if( ! doc ) return cb( null );

          // Make up the update object
          var updateObject = {};
          updateObject[ self.firstParentStoreField ] = doc.id;

          stores.workspacesContacts.dbLayer.update( { conditions: { and: [  { field: 'id', type: 'eq', value: request.params.contactId } ] } }, updateObject, function( err ){
            if( err ) return cb( err );


            stores.workspacesContacts.apiGet( request.params.contactId, function( err, contact ){
              if( err ) return cb( err );

              // NOTE: I undefine `beforeId` so that `broadcastStoreChanges` doesn't take it from the
              // HTTP headers, as the original call here is on the workspacesContactsEmails store,
              // and the putBefore would be wrong

              // Sends a storeRecordUpdate. Since the update is on fields that are NOT directly editable,
              // it will pass `keepForm` as true, so that editing forms open won't grey out
              stores.workspacesContacts.broadcastStoreChanges( request, 'storeRecordUpdate', contact.id, contact, { tabId: null, keepForm: true, beforeId: undefined }, cb );
            });
          });

        });
      },


      postEverything: function postEverything( request, method, p, done ){

        var self = this;
        self.inheritedAsync( postEverything, arguments, function( err ){
          if( err ) done( err );

          // Query methods will not affect the main record, so don't do anything
          if( method === 'get' || method === 'getQuery' ) return done( null );

          // Set the main record, passing the request
          self._setMain( request, done );
        });
      },
    });



    var WorkspacesContactsAddresses = declare( [ HotStore, MultiHomePermsMixin, UpdateFirstParentMixin ],  {

      firstParentStoreField: 'mainAddressId',

      schema: new HotSchema({
        label             : { type: 'string', required: false, trim: 64 },
        street            : { type: 'string', required: false, trim: 256 },
        poBox             : { type: 'string', required: false, trim: 64 },
        localArea         : { type: 'string', required: false, trim: 64 },
        city              : { type: 'string', required: false, trim: 64 },
        county            : { type: 'string', required: false, trim: 64 },
        postcode          : { type: 'string', required: false, trim: 10 },
        country           : { type: 'string', required: false, trim: 64 },
      }),

      onlineSearchSchema: new HotSchema({
        label             : { type: 'string' },
        street            : { type: 'string' },
        poBox             : { type: 'string' },
        localArea         : { type: 'string' },
        city              : { type: 'string' },
        county            : { type: 'string' },
        postcode          : { type: 'string' },
        country           : { type: 'string' },
      }),

      storeName:  'workspacesContactsAddresses',

      publicURL: '/workspaces/:workspaceId/Contacts/:contactId/addresses/:id',
      hotExpose: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      
      position: true,
    });
    stores.workspacesContactsAddresses = new WorkspacesContactsAddresses();


    var WorkspacesContactsEmailsBase = declare( [ HotStore, MultiHomePermsMixin ],  {

      schema: new HotSchema({

        id         : { type: 'id', searchable: true },
        workspaceId: { type: 'id', searchable: true },
        contactId  : { type: 'id', searchable: true },

        label      : { type: 'string', searchable: true, required: false, trim: 64 },
        email      : { type: 'string', searchable: true, required: true, notEmpty: true, sharedValidator: 'email', trim: 255, min: 4 },
      }),

      nested: [

        {
          layer: 'workspacesContacts',
          join: { 'id' : 'contactId' },
          type: 'lookup',
          parentField: 'contactId',
        },

      ],
      storeName:  'workspacesContactsEmailsBase',
      collectionName: 'workspacesContactsEmails',

      idProperty: 'id',

      position: true,
      hotExpose: false,

    });
    stores.workspacesContactsEmailsBase = new WorkspacesContactsEmailsBase();


    var WorkspacesContactsEmailsSearch = declare( [ WorkspacesContactsEmailsBase ],  {

      storeName:  'workspacesContactsEmailsSearch',
      collectionName: 'workspacesContactsEmails',

      publicURL: '/workspaces/:workspaceId/contactEmailsSearch/:id',
      hotExpose: true,

      handleGetQuery: true,      

      onlineSearchSchema: new HotSchema({

        isStarred: {
          type: 'boolean', trim: 20, searchOptions: {
            field: 'contactId.isStarred', condition: 'and'
          }
        },

        searchAll: { type: 'string', trim: 20, searchable: true, searchOptions: [
          { field: 'email',               type: 'startsWith', condition: 'or'  },
          { field: 'contactId.firstName', type: 'startsWith', condition: 'or'  },
          { field: 'contactId.lastName',  type: 'startsWith', condition: 'or'  },
        ] },
      }),

      //sortableFields: [ 'contactId.id', '__position' ],

      defaultSort: { 'contactId.id': 1, __position: 1 },

      // This is here to add `previousContactId` to each record, so that
      // the rendering can be done properly
      postEverything: function( request, method, p, done ){
 
        // Only affects getQuery
        if( method !== 'getQuery' ) return done( null );

        var queryDocs = p.queryDocs;

        // Assign null to the previous element
        if( queryDocs.length ) queryDocs[ 0 ].previousContactId = null;

        // Assign previousContactId to the remaining elements
        for( var i = 1, l = queryDocs.length; i < l; i ++){
          queryDocs[ i ].previousContactId = queryDocs[ i - 1 ].contactId;
        }

        done( null );
      }


    });
    stores.workspacesContactsEmailsSearch = new WorkspacesContactsEmailsSearch();


    var WorkspacesContactsEmails = declare( [ WorkspacesContactsEmailsBase, UpdateFirstParentMixin ],  {

      firstParentStoreField: 'mainEmailId',

      storeName:  'workspacesContactsEmails',
      collectionName: 'workspacesContactsEmails',

      publicURL: '/workspaces/:workspaceId/contacts/:contactId/emails/:id',
      hotExpose: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,      

      position: true,

      onlineSearchSchema: new HotSchema({
        label    : { type: 'string', required: false, trim: 64 },
        email    : { type: 'string', required: false, notEmpty: false, trim: 70 },
      }),

      // Don't allow the same email address twice
      postValidate: function( request, method, p, done ){
        var self = this;

        var body = request.body;

        if( method === 'get' || method === 'getQuery' ) return done( null );

        stores.workspacesContactsEmails.apiGetQuery( { filters: { email: body.email, contactId: body.contactId } },  function( err, docs ){
          if( err ) return done( err );

          // Filter self out (only need to do it for PUT calls)
          if( method === 'put' ){
            docs = docs.filter( function(i) { return i.id.toString() != body.id.toString() } );
          }

          if( docs.length ){
            var errors = [];
            errors.push( { field: 'email', message: 'Email address already on file' } );
            done( new self.UnprocessableEntityError( { errors: errors } ) );
          } else {
            done( null );
          }
        });
      },

    });
    stores.workspacesContactsEmails = new WorkspacesContactsEmails();


    var WorkspacesContactsPhoneNumbersBase = declare( [ HotStore, MultiHomePermsMixin ],  {
  
      schema: new HotSchema({
        id         : { type: 'id', searchable: true },
        workspaceId: { type: 'id', searchable: true },
        contactId  : { type: 'id', searchable: true },

        label     : { type: 'string', searchable: true, required: false, trim: 64 },
        dialCode  : { type: 'string', searchable: true, required: true, notEmpty: true, trim: 4, min: 1, sharedValidator: 'countryDialCode' },
        number    : { type: 'string', searchable: true, required: true, notEmpty: true, trim: 20, min: 1, sharedValidator: 'phoneNumber', },
      }),

      nested: [

        {
          layer: 'workspacesContacts',
          join: { 'id' : 'contactId' },
          type: 'lookup',
          parentField: 'contactId',
        },

      ],

      storeName:  'workspacesContactsPhoneNumbersBase',
      collectionName: 'workspacesContactsPhoneNumbers',

      idProperty: 'id',

      position: true,
      hotExpose: false,

    });
    stores.workspacesContactsPhoneNumbersBase = new WorkspacesContactsPhoneNumbersBase();


   var WorkspacesContactsPhoneNumbersSearch = declare( [ WorkspacesContactsPhoneNumbersBase ],  {

      storeName:  'workspacesContactsPhoneNumbersSearch',
      collectionName: 'workspacesContactsPhoneNumbers',

      publicURL: '/workspaces/:workspaceId/contactPhoneNumbersSearch/:id',
      hotExpose: true,

      handleGetQuery: true,      

      onlineSearchSchema: new HotSchema({

        isStarred: {
          type: 'boolean', trim: 20, searchOptions: {
            field: 'contactId.isStarred', condition: 'and'
          }
        },

        searchAll: { type: 'string', trim: 20, searchable: true, searchOptions: [
          { field: 'number',               type: 'startsWith', condition: 'or'  },
          { field: 'contactId.firstName', type: 'startsWith', condition: 'or'  },
          { field: 'contactId.lastName',  type: 'startsWith', condition: 'or'  },
        ] },
      }),

      defaultSort: { 'contactId.id': 1, __position: 1 },


      // This is here to add `previousContactId` to each record, so that
      // the rendering can be done properly
      postEverything: function( request, method, p, done ){
 
        // Only affects getQuery
        if( method !== 'getQuery' ) return done( null );

        var queryDocs = p.queryDocs;

        // Assign null to the previous element
        if( queryDocs.length ) queryDocs[ 0 ].previousContactId = null;

        // Assign previousContactId to the remaining elements
        for( var i = 1, l = queryDocs.length; i < l; i ++){
          queryDocs[ i ].previousContactId = queryDocs[ i - 1 ].contactId;
        }

        done( null );
      }

    });
    stores.workspacesContactsPhoneNumbersSearch = new WorkspacesContactsPhoneNumbersSearch();

    var WorkspacesContactsPhoneNumbers = declare( [ WorkspacesContactsPhoneNumbersBase, UpdateFirstParentMixin ],  {

      firstParentStoreField: 'mainPhoneNumberId',

      storeName:  'workspacesContactsPhoneNumbers',
      collectionName: 'workspacesContactsPhoneNumbers',

      publicURL: '/workspaces/:workspaceId/contacts/:contactId/phoneNumbers/:id',
      hotExpose: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,      

      position: true,

      onlineSearchSchema: new HotSchema({
        label     : { type: 'string' },
        dialCode  : { type: 'string' },
        number    : { type: 'string' },
      }),

    });
    stores.workspacesContactsPhoneNumbers = new WorkspacesContactsPhoneNumbers();

    var WorkspacesMessages = declare( [ HotStore, MultiHomePermsMixin ],  {

      schema: new HotSchema({
        added             : { type: 'date', searchable: true,  protected: true, default: function() { return new Date() } },
        incoming          : { type: 'boolean', required: false, protected: true, default: false },
   
        messageId         : { type: 'id', required: false, protected: true, searchable: true },

        // DoNotSave fields (they are in Messages)
        fromContactId     : { type: 'id', required: false },
        systemMessage     : { type: 'boolean', required: false, doNotSave: true }, 
        to                : { type: 'string', required: false, doNotSave: true, notEmpty: true, trim: 16000 },
        type              : { type: 'string', required: true, doNotSave: true, notEmpty: true, trim: 5, validator: function( o, v, fieldName ){  if( v !== 'email' && v !== 'sms' ) return "Type must be 'sms' or 'email' " } },

        subject           : { type: 'string', searchable: true, doNotSave: true, required: false, default: '',notEmpty: false, trim: 1024 },
        body              : { type: 'string', searchable: true, doNotSave: true, required: false, default: '', notEmpty: true, trim: 256000 },
      }),


      onlineSearchSchema: new HotSchema({
        incoming          : { type: 'boolean' },
        type              : { type: 'string', trim: 5 },

        // Contact search (from, to, either)
        fromContactId     : { type: 'id' },
        toContactId       : { type: 'id', searchOptions: [
          { field: 'workspacesMessagesTo.id', type: 'eq', condition: 'and'  },
        ]},
        contactId: { type: 'id', searchOptions: [
          { field: 'workspacesMessagesTo.contactId', type: 'eq', condition: 'or'  },
          { field: 'fromContactId',  type: 'eq', condition: 'or'  },
        ] },
      
      }),

      nested: [
        {
          layer: 'workspacesMessagesTo',
          join: { 'workspaceMessageId': 'id' },
          type: 'multiple'
        },

        /*
        {
          layer: 'workspacesMessagesAttachments',
          join: { 'workspaceMessageId': 'id' },
          type: 'multiple'
        },
        */

        {
          layer: 'workspacesContacts',
          join: { 'id': 'fromContactId' },
          type: 'lookup',
          parentField: 'fromContactId',          
        },

        {
          layer: 'messages',
          join: { 'id': 'messageId' },
          type: 'lookup',
          parentField: 'messageId',          
        },

      ],

      storeName:  'workspacesMessages',

      publicURL: '/workspaces/:workspaceId/messages/:id',
      hotExpose: true,

      handlePost: true,
      handleGet: true,
      handleGetQuery: true,

      alwaysRefreshOnChange: true,

      defaultSort: { 'added': -1 },
      sortableFields: [ 'added' ],

      // To understand what is going on, read the following comments for
      // postCheckPermissions() and  postDbOperation(), which are executed one after the other
      // When adding to this store, the only fields that are expected are:
      // to, type, subject, body.
      // However, NONE of them will actually be stored. This is what actually happens:
      // * incoming     : set to false
      // * fromContactId: set as the contact linked to the currently logged in user
      // * messageId    : first create an entry in transport.messages with from, type, subject, body
      //                  (with "from" taken from workspace config, and the rest from the optional fields)
      //                  and then set messageId as the transport's messageId
      // The field "to" is used to  get the list of IDs, and then add respective entries in transport:
      // * messagesTo
      // * workspacesMessagesTo.
      //
      // This is how it all happens:


      _selectFromContactId: function( request, done ){

        // REMOTE request 
        if( request.remote ){

          stores.workspacesContacts.apiGetQuery( { ranges: { limit: 1 }, filters: { userId: request._req.session.userId } }, function( err, docs ){
            if( err ) return done( err );

            // Paranoid check in case the linked contact wasn't found.
            if( docs.length === 0 ) return cb( new Error("Could not find contact linked to user while sending message"));

            // This is the contact linked to the user
            return done( null, docs[ 0 ].id );
          });

        // LOCAL request: use request.body.fromContactId
        } else {
          return done( null, request.body.fromContactId );
        }
       
      },


      postCheckPermissions: function( request, method, p, done ){
        if( method !== 'post' ) return done( null );

        // If the message is incoming, it means that it has actually already arrived and
        // it's already in the hotTransport tables. So, there is no need to do any of this
        if( request.body.incoming ) return done( null );

        var self = this;

        hotCoreStoreRegistry.getAllStores( function( err, storeRegistry ){
          if( err ) return done( err );

          var body = request.body;

          // ***********************
          // STEP 1: Work out fromContactId, from request (remote call) or passed parameter (API)
          // ***********************
          self._selectFromContactId( request, function( err, fromContactId ){
            if( err ) return done( err );

            // ***********************
            // STEP 2: Add the message to transport.messages, using type, subject, body  
            // ***********************

            storeRegistry.messages.apiPost( {
              incoming: false,
              type: body.type,
              subject: body.subject,
              bodyHtml: body.body,
              from: '' // Empty to start with, determined later as sending-time
            }, function( err, res ){
              if( err ) return done( err );

              // ********************************************
              // STEP 3: Enrich workspacesMessages.body with the right info
              // ********************************************              
              // THe "right info" is:
              // * Newly obtained messageId
              // * Incoming set to false
              // * Previoulsy obtained contactId, if there
              // ********************************************

              body.messageId = res.id;
              body.incoming = false;
              if( fromContactId ) body.fromContactId = fromContactId;

              // ********************************************
              // STEP 4: Work out which table the IDs passed in `to` are from
              // ********************************************              
              // They could be from:
              // * workspacesContactsPhoneNumbers
              // * workspacesContactsEmails
              // Depending on the message type. Saving it into workspacesContactsXXX
              // ********************************************

              // The workspacesContactsXXX will depend on the type: the IDs might be a bunch of email IDs
              // or a bunch of phone number IDs
              var workspacesContactsXXX;
              switch( request.body.type ) {
                case 'sms'  : workspacesContactsXXX = storeRegistry.workspacesContactsPhoneNumbers; break;
                case 'email': workspacesContactsXXX = storeRegistry.workspacesContactsEmails; break;
              }

              // *****************************************************************
              // STEP 5: Carry some information to the next hook
              // *****************************************************************
              // The information carried on to the next hook is:
              // * request.body.to          -- needed by next call, and about to get zapped
              //                               because of the doNotSave option
              // * request.body.type        -- Ditto
              // * workspacesContactsXXX    -- The right store, just worked out
              // * storeRegistry.messagesTo -- The messagesTo store
              //
              // The messagesTo store is passed for convenience: this way I
              // won't need to call hotCoreStoreRegistry.getAllStores again
              // ******************************************************************

              request.kept = { 
                to: request.body.to, // will get zapped
                type: request.body.type, // will get zapped
                workspacesContactsXXX: workspacesContactsXXX, // will be used by next call
                messagesTo: storeRegistry.messagesTo, // will be used by next call
              };

              done( null );
            });
          });
        });
      }, 

      _makeupTo: function( type, record ){
        switch( type ){
          case 'email': return record.email;
          case 'sms'  : return record.dialCode + record.number;
        }
      },


      // ******************************************************************
      // At this point, workspacesMessages and transport.message have
      // the message. It's now a matter of working on the `to` field
      // and fill workspacesMessagesTo and transport.messagesTo.
      // So, there we go...
      // ******************************************************************
      postDbOperation: function( request, method, p, done ){

        if( method !== 'post' ) return done( null );

        // If the message is incoming, it means that it has actually already arrived and
        // it's already in the hotTransport tables. So, there is no need to do any of this        
        if( request.body.incoming ) return done( null );

        var self = this;

        // ******************************************************************
        // For each item in `to`...
        // ******************************************************************

        async.eachSeries( 

          request.kept.to.split( ',' ),

          function( id, cb ){

            // *****************************************************************
            // STEP 6: Lookup the full to: information given the ID.
            // *****************************************************************
            // Note: this will use the right store, depending on the message type
            // ******************************************************************

            request.kept.workspacesContactsXXX.apiGet( id, function( err, info ){
              if( err ) return cb( err );

              // *****************************************************************
              // STEP 7: Add the message information to transport.messageTo
              // *****************************************************************

              // Add item to messagesTo
              request.kept.messagesTo.apiPost( {
                messageId: request.body.messageId,
                to: self._makeupTo( request.kept.type, info ),
                status: 'todeliver',
                failedAttempts: 0,
              }, function( err, messageTo ){
                if( err ) return cb( err );

                // *****************************************************************
                // STEP 8: Add the message information to workspacesMessagesTo
                // *****************************************************************

                stores.workspacesMessagesTo.apiPost({
                  workspaceId: request.body.workspaceId,
                  workspaceMessageId: p.fullDoc.id,
                  contactId: info.contactId,      
                  messageToId: messageTo.id,
                  messageId: request.body.messageId

                }, function( err, messageToContact ){
                  if( err ) return cb( err );

                  cb( null );

                });    

              });

            });            
          },

          function( err ){
            if( err ) return done( err );

            done( null );
          }
        );
      },       


    });
    stores.workspacesMessages = new WorkspacesMessages();


    var WorkspacesMessagesTo = declare( [ HotStore, MultiHomePermsMixin ],  {

      schema: new HotSchema({

        messageToId       : { type: 'id', required: false, searchable: true },        
        contactId         : { type: 'id', required: false, searchable: true },

        billable          : { type: 'boolean', required: false, default: true },

        messageId         : { type: 'id', required: true, searchable: true }, // NN

      }),

      onlineSearchSchema: new HotSchema({
      }),

      storeName:  'workspacesMessagesTo',

      publicURL: '/workspaces/:workspaceId/messages/:workspaceMessageId/toContacts/:id',
      hotExpose: true,

      handleGet: true,
      handleGetQuery: true,
      
    });
    stores.workspacesMessagesTo = new WorkspacesMessagesTo();


    /*
    var WorkspacesMessagesAttachments = declare( [ HotStore, MultiHomePermsMixin ],  {

      schema: new HotSchema({

        messageAttachmentId: { type: 'id', required: true, searchable: true },        
        messageId          : { type: 'id', required: true, searchable: true }, // NN
      }),

      onlineSearchSchema: new HotSchema({
      }),

      storeName:  'workspacesMessagesAttachments',

      publicURL: '/workspaces/:workspaceId/messages/:workspaceMessageId/attachments/:id',
      hotExpose: true,

      handleGet: true,
      handleGetQuery: true,
      
    });
    stores.workspacesMessagesAttachments = new WorkspacesMessagesAttachments();
    */


    // Root-level store
    var PhoneNumbers = declare( [ HotStore ], {

      schema: new HotSchema({
        fullNumber        : { type: 'string', required: true,  notEmpty: true, trim: 50, searchable: true, searchOptions: { type: 'contains' },  },
        type              : { type: 'string', required: true,  notEmpty: true, trim: 9, searchable: true, searchOptions: { type: 'is' }, validator: function( o, v, fieldName ){  if( v !== 'private' && v !== 'shared' && v !== 'available') return "Type must be 'private', 'available' or 'shared' " } },
        provider          : { type: 'string', required: true,  notEmpty: true, trim: 10, searchable: true, searchOptions: { type: 'is' }, validator: function( o, v, fieldName ){  if( v !== 'twilio' && v !== 'plivo' ) return "Provider must be 'plivo' or 'twilio' " } },
        ownedByWorkspaceId: { type: 'id', required: false, notEmpty: true, searchable: true, searchOptions: { type: 'is' }, validator: function( o, v, fieldName ){  if( o.type == 'private' && ! v ) return "You need to specify the workspace ID for private phone numbers" } },
        workspaceId: { type: 'id', searchable: true, doNotSave: true, searchOptions: [ { field: 'ownedByWorkspaceId', type: 'is', condition: 'or', }, { field: 'type', type: 'is', value: 'shared', condition: 'or' } ] }
      }),

      //onlineSearchSchema: new HotSchema({
      //}),

      storeName:  'phoneNumbers',
      publicURL: '/phoneNumbers/:id',
      hotExpose: true,
  
      alwaysRefreshOnChange: true,

      position: true,

      hotGlobalBroadcast: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,  
    });
    stores.phoneNumbers = new PhoneNumbers();

    // Plivo config store
    var PlivoConfig = declare( [ HotStore ], {

      schema: new HotSchema({
        account         : { type: 'string', notEmpty: false, trim: 50, searchable: true },
        token           : { type: 'string', notEmpty: false, trim: 50, searchable: true },        
      }),

      onlineSearchSchema: new HotSchema({
      }),

      storeName:  'plivoConfig',
      publicURL: '/config/plivoConfig/:globalId',
      hotExpose: true,
      configStore: { globalId: true },

      position: true,

      hotGlobalBroadcast: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      
    });
    stores.plivoConfig = new PlivoConfig();

    var WorkspacesEmailConfig = declare( [ HotStore, MultiHomePermsMixin ], {

      schema: new HotSchema({
        systemName  : { type: 'string', required: false, default: "Email system", notEmpty: true, trim: 70},
        systemEmail : { type: 'string', required: false, default: "youremail@example.com", sharedValidator: 'email', notEmpty: true, trim: 255},
        smtpServer      : { type: 'string', required: false,  trim: 256, },
        smtpPort        : { type: 'number', required: true, default: '586' },        
        smtpLogin       : { type: 'string', required: false,  trim: 256, },
        smtpPassword    : { type: 'string', required: false,  trim: 256, },

        imapServer      : { type: 'string', required: false,  trim: 256, },
        imapPort        : { type: 'number', required: true, default: '993' },        
        imapLogin       : { type: 'string', required: false,  trim: 256, },
        imapPassword    : { type: 'string', required: false,  trim: 256, },
        imapPollInterval: { type: 'number', required: true, default: '300', min: 60, max: 600 },

      }),

      onlineSearchSchema: new HotSchema({
      }),

      storeName:  'workspacesEmailConfig',

      publicURL: '/config/workspacesEmailConfig/:workspaceId',
      hotExpose: true,
      configStore: { workspaceId: true },

      handlePut: true,
      handleGet: true,

      prepareBeforeSend: function( request, method, p, cb ){
        p.doc.id = p.doc.workspaceId;
        cb( null, p.doc );
      },

    });
    stores.workspacesEmailConfig = new WorkspacesEmailConfig();



    var WorkspacesSmsConfig = declare( [ HotStore, MultiHomePermsMixin ], {

      schema: new HotSchema({
        phoneNumberId : { searchable: true, type: 'id', required: false },
      }),

      onlineSearchSchema: new HotSchema({
      }),

      nested: [
        {
          layer: 'phoneNumbers',
          join: { 'id' : 'phoneNumberId' },
          type: 'lookup',
          parentField: 'phoneNumberId',
        },
      ],

      storeName:  'workspacesSmsConfig',

      publicURL: '/config/workspacesSmsConfig/:workspaceId',
      hotExpose: true,
      configStore: { workspaceId: true },

      handlePut: true,
      handleGet: true,
    });
    stores.workspacesSmsConfig = new WorkspacesSmsConfig();


/*
* Rest store ("straight", no cache)
 * Case SNUe: natural collection, unfiltered, put with defaultNewToStart=false
 * Case SNUs: natural collection, unfiltered, put with defaultNewToStart=true
 * Case SOU: ordered collection, unfiltered (Refresh)
 * Case SOF: ordered collection, filtered (Refresh)
 * Case SNFe: natural collection, filtered, put with defaultNewToStart=false (Refresh)
 * Case SNFs: natural collection, filtered, put with defaultNewToStart=true (Refresh)

* Rest store (cached)
 * Case CNUe: natural collection, unfiltered, put with defaultNewToStart=false
 * Case CNUs: natural collection, unfiltered, put with defaultNewToStart=true
 * Case COU: ordered collection, unfiltered (QueryEngine)
 * Case COF: ordered collection, filtered (QueryEngine)
 * Case CNFe: natural collection, filtered, put with defaultNewToStart=false (QueryEngine)
 * Case CNFs: natural collection, filtered, put with defaultNewToStart=true (QueryEngine)
*/


    // * Case SNUe: natural collection, unfiltered, put with defaultNewToStart=false
    var SNUe = declare( [ HotStore ],  {

      type: 'uncached',

      schema: new HotSchema({
        name: { type: 'string', required: true, notEmpty: true, trim: 10 },
      }),

      storeName:  'snue',
      publicURL: '/testStores/snue/:id',
      position: true,

      // All enabled by default
      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      handleDelete: true,

      // Exposed through hotplate
      hotExpose: true,

    });
    stores.snue = new SNUe();

    // * Case SNUs: natural collection, unfiltered, put with defaultNewToStart=true
    var SNUs = declare( [ HotStore ],  {

      type: 'uncached',

      schema: new HotSchema({
        name: { type: 'string', required: true, notEmpty: true, trim: 10 },
      }),

      storeName:  'snus',
      publicURL: '/testStores/snus/:id',
      position: true,
      defaultNewToStart: true,
      
      // All enabled by default
      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      handleDelete: true,

      // Exposed through hotplate
      hotExpose: true,

    });
    stores.snus = new SNUs();

    // * Case SOU: ordered collection, unfiltered (Refresh)
    var SOU = declare( [ HotStore ],  {

      type: 'uncached',

      schema: new HotSchema({
        name: { type: 'string', required: true, notEmpty: true, trim: 10, searchable: true },
      }),

      storeName:  'sou',
      publicURL: '/testStores/sou/:id',
      position: false,
      sortableFields: [ 'name' ],

      // All enabled by default
      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      handleDelete: true,

      // Exposed through hotplate
      hotExpose: true,

    });
    stores.sou = new SOU();

    //* Case SOF: ordered collection, filtered (Refresh)
    var SOF = declare( [ HotStore ],  {

      type: 'uncached',

      schema: new HotSchema({
        name: { type: 'string', required: true, notEmpty: true, trim: 10, searchable: true },
      }),

      storeName:  'sof',
      publicURL: '/testStores/sof/:id',
      position: false,
      sortableFields: [ 'name' ],

      // All enabled by default
      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      handleDelete: true,

      // Exposed through hotplate
      hotExpose: true,

    });
    stores.sof = new SOF();

    // * Case SNFe: natural collection, filtered, put with defaultNewToStart=false (Refresh)
    var SNFe = declare( [ HotStore ],  {

      type: 'uncached',

      schema: new HotSchema({
        name: { type: 'string', required: true, notEmpty: true, trim: 10, searchable: true },
      }),

      storeName:  'snfe',
      publicURL: '/testStores/snfe/:id',
      position: true,

      // All enabled by default
      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      handleDelete: true,

      // Exposed through hotplate
      hotExpose: true,

    });
    stores.snfe = new SNFe();

    // * Case SNFs: natural collection, filtered, put with defaultNewToStart=true (Refresh)
    var SNFs = declare( [ HotStore ],  {

      type: 'uncached',

      schema: new HotSchema({
        name: { type: 'string', required: true, notEmpty: true, trim: 10, searchable: true },
      }),

      storeName:  'snfs',
      publicURL: '/testStores/snfs/:id',
      position: true,
      defaultNewToStart: true,

      // All enabled by default
      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      handleDelete: true,

      // Exposed through hotplate
      hotExpose: true,

    });
    stores.snfs = new SNFs();


    // * Case CNUe: natural collection, unfiltered, put with defaultNewToStart=false
    var CNUe = declare( [ HotStore ],  {

      type: 'cached',

      schema: new HotSchema({
        name: { type: 'string', required: true, notEmpty: true, trim: 10 },
      }),

      storeName:  'cnue',
      publicURL: '/testStores/cnue/:id',
      position: true,

      // All enabled by default
      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      handleDelete: true,

      // Exposed through hotplate
      hotExpose: true,

    });
    stores.cnue = new CNUe();

    // * Case CNUs: natural collection, unfiltered, put with defaultNewToStart=true
    var CNUs = declare( [ HotStore ],  {

      type: 'cached',

      schema: new HotSchema({
        name: { type: 'string', required: true, notEmpty: true, trim: 10 },
      }),

      storeName:  'cnus',
      publicURL: '/testStores/cnus/:id',
      position: true,
      defaultNewToStart: true,
      
      // All enabled by default
      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      handleDelete: true,

      // Exposed through hotplate
      hotExpose: true,

    });
    stores.cnus = new CNUs();

    // * Case COU: ordered collection, unfiltered (QueryEngine)
    var COU = declare( [ HotStore ],  {

      type: 'cached',

      schema: new HotSchema({
        name: { type: 'string', required: true, notEmpty: true, trim: 10, searchable: true },
      }),

      storeName:  'cou',
      publicURL: '/testStores/cou/:id',
      position: false,
      sortableFields: [ 'name' ],

      // All enabled by default
      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      handleDelete: true,

      // Exposed through hotplate
      hotExpose: true,

    });
    stores.cou = new COU();

    //* Case COF: ordered collection, filtered (QueryEngine)
    var COF = declare( [ HotStore ],  {

      type: 'cached',

      schema: new HotSchema({
        name: { type: 'string', required: true, notEmpty: true, trim: 10, searchable: true },
      }),

      storeName:  'cof',
      publicURL: '/testStores/cof/:id',
      position: false,
      sortableFields: [ 'name' ],

      // All enabled by default
      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      handleDelete: true,

      // Exposed through hotplate
      hotExpose: true,

    });
    stores.cof = new COF();

    // * Case CNFe: natural collection, filtered, put with defaultNewToStart=false (QueryEngine)
    var CNFe = declare( [ HotStore ],  {

      type: 'cached',

      schema: new HotSchema({
        name: { type: 'string', required: true, notEmpty: true, trim: 10, searchable: true },
      }),

      storeName:  'cnfe',
      publicURL: '/testStores/cnfe/:id',
      position: true,

      // All enabled by default
      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      handleDelete: true,

      // Exposed through hotplate
      hotExpose: true,

    });
    stores.cnfe = new CNFe();

    // * Case CNFs: natural collection, filtered, put with defaultNewToStart=true (QueryEngine)
    var CNFs = declare( [ HotStore ],  {

      type: 'cached',

      schema: new HotSchema({
        name: { type: 'string', required: true, notEmpty: true, trim: 10, searchable: true },
      }),

      storeName:  'cnfs',
      publicURL: '/testStores/cnfs/:id',
      position: true,
      defaultNewToStart: true,

      // All enabled by default
      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      handleDelete: true,

      // Exposed through hotplate
      hotExpose: true,

    });
    stores.cnfs = new CNFs();




    done( null, stores );
  });

}));


// Simply activate path to client files
hotplate.hotEvents.on( 'clientPath', 'bd', function( done ){
  done( null, path.join(__dirname, '../client') );
} )

// Define which paths within clientPath will need to be rendered, and with which options
hotplate.hotEvents.on( 'clientPathRender', 'bd', function( done ){
  done( null, [
    {
      'templates/BookingDojo.jade': { name: 'Tony' },
      'templates/AnotherBookingDojo.jade': {},
    }
  ] );
} )



hotplate.hotEvents.on( 'dojoModulesPerPage', 'bd', function( req, pageName, done ){

  switch( pageName ){

    case 'hotDojoAppContainer/container':
      done( null, [ 'bdMain' ] );
    break;

    default:
      done( null, [ ] );
    break;
  }

});


hotplate.hotEvents.on( 'pageElements', 'bd', function( done ){
    done( null, { titleWords: [ "Booking Dojo" ] } );
})

hotplate.hotEvents.on( 'pageElementsPerPage', 'bd', function( req, pageName, done ){

  switch(pageName){

    case 'hotDojoAppContainer/container':

      // Sending the page out
      done( null, {
        csses: ['bdMain.css' ],
        titleWords: [ "Application" ],
      });

    break;

   default:
      done( null, {} );
    break;
  }
});


"use strict";

var hotplate = require('hotplate');


hotplate.hotEvents.on( 'sharedFunctions', 'bd', hotplate.cachable( function( done ) {

  var result = {};

  result.phoneNumberValidator = function( number ){
    if( number === false ) return "Phone number invalid, only numbers and spaces allowed";
    return number.match( /^[0-9 ]+$/ );
  };


  result.dialCodeValidator = function( code ){

    var dialCodes = {
      93:'Afghanistan',
      355:'Albania',
      213:'Algeria',
      1684:'American Samoa',
      376:'Andorra',
      244:'Angola',
      1264:'Anguilla',
      1268:'Antigua and Barbuda',
      54:'Argentina',
      374:'Armenia',
      297:'Aruba',
      247:'Ascension Island',
      61:'Australia',
      43:'Austria',
      994:'Azerbaijan',
      1242:'Bahamas',
      973:'Bahrain',
      880:'Bangladesh',
      1246:'Barbados',
      375:'Belarus',
      32:'Belgium',
      501:'Belize',
      229:'Benin',
      1441:'Bermuda',
      975:'Bhutan',
      591:'Bolivia',
      599:'Bonaire - Sint Eustatius and Saba',
      387:'Bosnia and Herzegovina',
      267:'Botswana',
      55:'Brazil',
      673:'Brunei',
      359:'Bulgaria',
      226:'Burkina Faso',
      257:'Burundi',
      855:'Cambodia',
      237:'Cameroon',
      1:'Canada',
      238:'Cape Verde',
      1345:'Cayman Islands',
      236:'Central African Republic',
      235:'Chad',
      56:'Chile',
      86:'China',
      57:'Colombia',
      269:'Comoros and Mayotte',
      242:'Congo',
      243:'Congo Dem Rep',
      682:'Cook Islands',
      506:'Costa Rica',
      225:'Cote d\'Ivoire',
      385:'Croatia',
      53:'Cuba',
      599:'Curaçao',
      357:'Cyprus',
      420:'Czech Republic',
      45:'Denmark',
      246:'Diego Garcia',
      253:'Djibouti',
      1767:'Dominica',
      1809:'Dominican Republic',
      593:'Ecuador',
      20:'Egypt',
      503:'El Salvador',
      240:'Equatorial Guinea',
      291:'Eritrea',
      372:'Estonia',
      251:'Ethiopia',
      500:'Falkland Islands',
      298:'Faroe Islands',
      679:'Fiji',
      358:'Finland',
      33:'France',
      594:'French Guiana',
      689:'French Polynesia',
      241:'Gabon',
      220:'Gambia',
      995:'Georgia',
      49:'Germany',
      233:'Ghana',
      350:'Gibraltar',
      30:'Greece',
      299:'Greenland',
      1473:'Grenada',
      590:'Guadeloupe',
      1671:'Guam',
      502:'Guatemala',
      224:'Guinea',
      245:'Guinea Bissau',
      592:'Guyana',
      509:'Haiti',
      504:'Honduras',
      852:'Hong Kong',
      36:'Hungary',
      354:'Iceland',
      91:'India',
      62:'Indonesia',
      98:'Iran',
      964:'Iraq',
      353:'Ireland',
      972:'Israel',
      39:'Italy',
      1876:'Jamaica',
      81:'Japan',
      962:'Jordan',
      7:'Kazakhstan',
      254:'Kenya',
      686:'Kiribati',
      850:'Korea - North',
      82:'Korea - South',
      965:'Kuwait',
      996:'Kyrgyzstan',
      856:'Laos',
      371:'Latvia',
      961:'Lebanon',
      266:'Lesotho',
      231:'Liberia',
      218:'Libya',
      423:'Liechtenstein',
      370:'Lithuania',
      352:'Luxembourg',
      853:'Macao',
      389:'Macedonia',
      261:'Madagascar',
      265:'Malawi',
      60:'Malaysia',
      960:'Maldives',
      223:'Mali',
      356:'Malta',
      692:'Marshall Islands',
      596:'Martinique',
      222:'Mauritania',
      230:'Mauritius',
      52:'Mexico',
      691:'Micronesia',
      373:'Moldova',
      377:'Monaco',
      976:'Mongolia',
      382:'Montenegro',
      1664:'Montserrat',
      212:'Morocco',
      258:'Mozambique',
      95:'Myanmar',
      264:'Namibia',
      674:'Nauru',
      977:'Nepal',
      31:'Netherlands',
      687:'New Caledonia',
      64:'New Zealand',
      505:'Nicaragua',
      227:'Niger',
      234:'Nigeria',
      683:'Niue',
      6723:'Norfolk Island',
      1:'Northern Mariana Islands',
      47:'Norway',
      968:'Oman',
      92:'Pakistan',
      680:'Palau',
      970:'Palestine',
      507:'Panama',
      675:'Papua New Guinea',
      595:'Paraguay',
      51:'Peru',
      63:'Philippines',
      48:'Poland',
      351:'Portugal',
      1787:'Puerto Rico',
      974:'Qatar',
      262:'Reunion',
      40:'Romania',
      7:'Russia',
      250:'Rwanda',
      590:'Saint Barthélemy',
      290:'Saint Helena',
      1869:'Saint Kitts and Nevis',
      1758:'Saint Lucia',
      590:'Saint Martin',
      508:'Saint Pierre and Miquelon',
      1784:'Saint Vincent Grenadines',
      685:'Samoa',
      378:'San Marino',
      239:'Sao Tome and Principe',
      966:'Saudi Arabia',
      221:'Senegal',
      381:'Serbia',
      248:'Seychelles',
      232:'Sierra Leone',
      65:'Singapore',
      1721:'Sint Maarten',
      421:'Slovakia',
      386:'Slovenia',
      677:'Solomon Islands',
      252:'Somalia',
      27:'South Africa',
      211:'South Sudan',
      34:'Spain',
      94:'Sri Lanka',
      249:'Sudan',
      597:'Suriname',
      268:'Swaziland',
      46:'Sweden',
      41:'Switzerland',
      963:'Syria',
      886:'Taiwan',
      992:'Tajikistan',
      255:'Tanzania',
      66:'Thailand',
      670:'Timor-Leste',
      228:'Togo',
      690:'Tokelau',
      676:'Tonga',
      1868:'Trinidad and Tobago',
      216:'Tunisia',
      90:'Turkey',
      993:'Turkmenistan',
      1649:'Turks and Caicos',
      688:'Tuvalu',
      256:'Uganda',
      380:'Ukraine',
      971:'United Arab Emirates',
      44:'United Kingdom',
      1:'United States',
      598:'Uruguay',
      998:'Uzbekistan',
      678:'Vanuatu',
      379:'Vatican City',
      58:'Venezuela',
      84:'Vietnam',
      1284:'Virgin Islands - British',
      1340:'Virgin Islands - US',
      681:'Wallis and Futuna',
      967:'Yemen',
      260:'Zambia',
      263:'Zimbabwe',
    }

    if( code === false ) return "Country code invalid";
    return !! dialCodes[ code ];
  };

  result.countryDialCodes = function(){
    return {
      93:'Afghanistan',
      355:'Albania',
      213:'Algeria',
      1684:'American Samoa',
      376:'Andorra',
      244:'Angola',
      1264:'Anguilla',
      1268:'Antigua and Barbuda',
      54:'Argentina',
      374:'Armenia',
      297:'Aruba',
      247:'Ascension Island',
      61:'Australia',
      43:'Austria',
      994:'Azerbaijan',
      1242:'Bahamas',
      973:'Bahrain',
      880:'Bangladesh',
      1246:'Barbados',
      375:'Belarus',
      32:'Belgium',
      501:'Belize',
      229:'Benin',
      1441:'Bermuda',
      975:'Bhutan',
      591:'Bolivia',
      599:'Bonaire - Sint Eustatius and Saba',
      387:'Bosnia and Herzegovina',
      267:'Botswana',
      55:'Brazil',
      673:'Brunei',
      359:'Bulgaria',
      226:'Burkina Faso',
      257:'Burundi',
      855:'Cambodia',
      237:'Cameroon',
      1:'Canada',
      238:'Cape Verde',
      1345:'Cayman Islands',
      236:'Central African Republic',
      235:'Chad',
      56:'Chile',
      86:'China',
      57:'Colombia',
      269:'Comoros and Mayotte',
      242:'Congo',
      243:'Congo Dem Rep',
      682:'Cook Islands',
      506:'Costa Rica',
      225:'Cote d\'Ivoire',
      385:'Croatia',
      53:'Cuba',
      599:'Curaçao',
      357:'Cyprus',
      420:'Czech Republic',
      45:'Denmark',
      246:'Diego Garcia',
      253:'Djibouti',
      1767:'Dominica',
      1809:'Dominican Republic',
      593:'Ecuador',
      20:'Egypt',
      503:'El Salvador',
      240:'Equatorial Guinea',
      291:'Eritrea',
      372:'Estonia',
      251:'Ethiopia',
      500:'Falkland Islands',
      298:'Faroe Islands',
      679:'Fiji',
      358:'Finland',
      33:'France',
      594:'French Guiana',
      689:'French Polynesia',
      241:'Gabon',
      220:'Gambia',
      995:'Georgia',
      49:'Germany',
      233:'Ghana',
      350:'Gibraltar',
      30:'Greece',
      299:'Greenland',
      1473:'Grenada',
      590:'Guadeloupe',
      1671:'Guam',
      502:'Guatemala',
      224:'Guinea',
      245:'Guinea Bissau',
      592:'Guyana',
      509:'Haiti',
      504:'Honduras',
      852:'Hong Kong',
      36:'Hungary',
      354:'Iceland',
      91:'India',
      62:'Indonesia',
      98:'Iran',
      964:'Iraq',
      353:'Ireland',
      972:'Israel',
      39:'Italy',
      1876:'Jamaica',
      81:'Japan',
      962:'Jordan',
      7:'Kazakhstan',
      254:'Kenya',
      686:'Kiribati',
      850:'Korea - North',
      82:'Korea - South',
      965:'Kuwait',
      996:'Kyrgyzstan',
      856:'Laos',
      371:'Latvia',
      961:'Lebanon',
      266:'Lesotho',
      231:'Liberia',
      218:'Libya',
      423:'Liechtenstein',
      370:'Lithuania',
      352:'Luxembourg',
      853:'Macao',
      389:'Macedonia',
      261:'Madagascar',
      265:'Malawi',
      60:'Malaysia',
      960:'Maldives',
      223:'Mali',
      356:'Malta',
      692:'Marshall Islands',
      596:'Martinique',
      222:'Mauritania',
      230:'Mauritius',
      52:'Mexico',
      691:'Micronesia',
      373:'Moldova',
      377:'Monaco',
      976:'Mongolia',
      382:'Montenegro',
      1664:'Montserrat',
      212:'Morocco',
      258:'Mozambique',
      95:'Myanmar',
      264:'Namibia',
      674:'Nauru',
      977:'Nepal',
      31:'Netherlands',
      687:'New Caledonia',
      64:'New Zealand',
      505:'Nicaragua',
      227:'Niger',
      234:'Nigeria',
      683:'Niue',
      6723:'Norfolk Island',
      1:'Northern Mariana Islands',
      47:'Norway',
      968:'Oman',
      92:'Pakistan',
      680:'Palau',
      970:'Palestine',
      507:'Panama',
      675:'Papua New Guinea',
      595:'Paraguay',
      51:'Peru',
      63:'Philippines',
      48:'Poland',
      351:'Portugal',
      1787:'Puerto Rico',
      974:'Qatar',
      262:'Reunion',
      40:'Romania',
      7:'Russia',
      250:'Rwanda',
      590:'Saint Barthélemy',
      290:'Saint Helena',
      1869:'Saint Kitts and Nevis',
      1758:'Saint Lucia',
      590:'Saint Martin',
      508:'Saint Pierre and Miquelon',
      1784:'Saint Vincent Grenadines',
      685:'Samoa',
      378:'San Marino',
      239:'Sao Tome and Principe',
      966:'Saudi Arabia',
      221:'Senegal',
      381:'Serbia',
      248:'Seychelles',
      232:'Sierra Leone',
      65:'Singapore',
      1721:'Sint Maarten',
      421:'Slovakia',
      386:'Slovenia',
      677:'Solomon Islands',
      252:'Somalia',
      27:'South Africa',
      211:'South Sudan',
      34:'Spain',
      94:'Sri Lanka',
      249:'Sudan',
      597:'Suriname',
      268:'Swaziland',
      46:'Sweden',
      41:'Switzerland',
      963:'Syria',
      886:'Taiwan',
      992:'Tajikistan',
      255:'Tanzania',
      66:'Thailand',
      670:'Timor-Leste',
      228:'Togo',
      690:'Tokelau',
      676:'Tonga',
      1868:'Trinidad and Tobago',
      216:'Tunisia',
      90:'Turkey',
      993:'Turkmenistan',
      1649:'Turks and Caicos',
      688:'Tuvalu',
      256:'Uganda',
      380:'Ukraine',
      971:'United Arab Emirates',
      44:'United Kingdom',
      1:'United States',
      598:'Uruguay',
      998:'Uzbekistan',
      678:'Vanuatu',
      379:'Vatican City',
      58:'Venezuela',
      84:'Vietnam',
      1284:'Virgin Islands - British',
      1340:'Virgin Islands - US',
      681:'Wallis and Futuna',
      967:'Yemen',
      260:'Zambia',
      263:'Zimbabwe',
    }
  };
  done( null, result );
}));


