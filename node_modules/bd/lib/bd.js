var
  dummy

, hotplate =  require('hotplate')
, path = require('path')
, async = require('async')
, debug = require('debug')('bd')
, emailaddresses = require( 'email-addresses')

, declare = require( 'simpledeclare' )

, hotCoreJsonRestStores = hotplate.require('hotCoreJsonRestStores')
, hotCoreMultiHome = hotplate.require('hotCoreMultiHome')
, hotCoreStoreRegistry = hotplate.require( 'hotCoreStoreRegistry' )
, hotCoreServerLogger = hotplate.require( 'hotCoreServerLogger' )
, logger = hotCoreServerLogger
, JsonRestStores = require( 'jsonreststores' )
, SimpleSchema = require( 'simpleschema' )
;

JsonRestStores.artificialDelay = 500;

// Hooks to manage SMSes
require('./messagesManager.js')

// Hooks to manage the stores test (to be eradicated)
require('./storesTest.js')

require('./dialCodes.js')


hotplate.hotEvents.on( 'run', 'bd', hotplate.cachable( function( done ){

  hotCoreStoreRegistry.getAllStores( function( err, storeRegistry ){
    if( err ) return done( err );

    // Redefine afterEverything() for workspaceUsersBase, workspacesUsers, usersWorkspaces
    // It WAS: overrideMethod
    storeRegistry.workspacesUsersBase.afterEverything = function f( request, method, p, cb ){
      this.inheritedAsync( f, arguments, function( err ){
        if( err ) return done( err );

        // Only do anything for 'post'
        if( method !== 'post' ) return cb( null );
        storeRegistry.workspacesContacts.apiPost( { userId: p.doc.userId, workspaceId: p.doc.workspaceId }, {}, cb )
      });
    };
    storeRegistry.workspacesUsers.afterEverything = function f( request, method, p, cb ){
      this.inheritedAsync( f, arguments, function( err ){
        if( err ) return done( err );

        // Only do anything for 'post'
        if( method !== 'post' ) return cb( null );
        storeRegistry.workspacesContacts.apiPost( { userId: p.doc.userId, workspaceId: p.doc.workspaceId }, {}, cb );
      });
    };
    storeRegistry.usersWorkspaces.afterEverything = function f( request, method, p, cb ){
      this.inheritedAsync( f, arguments, function( err ){
        if( err ) return done( err );

        // Only do anything for 'post'
        if( method !== 'post' ) return cb( null );
        storeRegistry.workspacesContacts.apiPost( { userId: p.doc.userId, workspaceId: p.doc.workspaceId }, {}, cb );
      });
    };

    
    // End of Hotplate's 'run' hook
    done( null );
  });

}));


hotplate.hotEvents.on( 'stores', 'bd', hotplate.cachable( function( done ){

  var stores = {};

  var MultiHomePermsMixin = hotCoreMultiHome.MultiHomeBasicPermissionsMixin;
  var PrivateUserDataMixin = hotCoreJsonRestStores.PrivateUserDataPermissionsMixin;

  hotCoreJsonRestStores.get( function( err, s ){
    if( err ) return done( err );

    var HotStore = s.HotStore;
    var HotSchema = s.HotSchema;
    var BasicDbStore = s.BasicDbStore;
    var BasicSchema = s.BasicSchema;

    var UsersInfo = declare( [ HotStore, MultiHomePermsMixin, PrivateUserDataMixin ], {

      schema: new HotSchema({
        email       :  { type: 'string', required: true, default: "youremail@example.com", notEmpty: true, sharedValidator: 'email', trim: 255, min: 4 },
        //surname     :  { type: 'string', required: true, default: "Your surname", notEmpty: true, trim: 10 },
        //name        :  { type: 'string', required: true, default: "Your name", notEmpty: true, trim: 50 },
      }),

      onlineSearchSchema: new HotSchema({
        email     : { type: 'string' },
        //surname   : { type: 'string' },
        //name      : { type: 'string' },
      }),

      handlePut: true,
      handleGet: true,

      storeName:  'usersInfo',

      publicURL: '/config/users/:userId',
      hotExpose: true,
      configStore: { userId: true },
    });
    stores.usersInfo = new UsersInfo();


    var UsersInterests = declare( [ HotStore, MultiHomePermsMixin, PrivateUserDataMixin ], {

      schema: new HotSchema({
        name          : { type: 'string', required: true, trim: 35, searchable: true },
      }),

      onlineSearchSchema: new HotSchema({
      }),

      storeName: 'usersInterests',

      publicURL: '/config/users/:userId/interests/:id',
      hotExpose: true,
      configStore: { userId: true },

      defaultNewToStart: true,

      position: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      
    });
    stores.usersInterests = new UsersInterests();


    var WorkspacesInfo = declare( [ HotStore, MultiHomePermsMixin ], {

      schema: new HotSchema({
        longName: { 
          type: 'string', 
          required: true, 
          default: "Workspace's long name", 
          notEmpty: true, 
          trim: 35, 
          searchable: true
        },
        tag: { 
          type: 'string', 
          required: true, 
          default: "Workspace's tag line",
          notEmpty: true,
          trim: 70,
          searchable: true
        },
        statsUse: {
          type: 'id',
          required: false,
          notEmpty: false
        },
        countryDialCodeDefault: { 
          type: 'string',
          required: false,
          notEmpty: true,
          trim: 4,
          min: 1,
          sharedValidator: 'countryDialCode'
        },
      }),

      onlineSearchSchema: new HotSchema({
      }),

      storeName:  'workspacesInfo',

      publicURL: '/config/workspacesInfo/:workspaceId',
      hotExpose: true,
      configStore: { workspaceId: true },

      handlePut: true,
      handleGet: true,
    });
    stores.workspacesInfo = new WorkspacesInfo();


    var WorkspacesUsersInfo = declare( [ HotStore, MultiHomePermsMixin, PrivateUserDataMixin ], {

      schema: new HotSchema({
        setting1          : { type: 'string',  required: true, default: 'Default 1', notEmpty: true,  trim: 35 },
        orderByNameDefault: { type: 'boolean', required: true, default: true },
        notificationsEmailAddress  : { type: 'id',  required: false },
      }),

      onlineSearchSchema: new HotSchema({
      }),

      storeName: 'workspacesUsersInfo',

      publicURL: '/config/workspaces/:workspaceId/users/:userId',
      hotExpose: true,
      configStore: { workspaceId: true, userId: true },

      handlePut: true,
      handleGet: true,

      nested: [
        {
          layer: 'workspacesContacts',
          join: { userId: 'userId' },
          type: 'multiple',
        }
      ],

    });
    stores.workspacesUsersInfo = new WorkspacesUsersInfo();


    var WorkspacesUsersActivities = declare( [ HotStore, MultiHomePermsMixin, PrivateUserDataMixin ], {

      schema: new HotSchema({
        name        : { type: 'string', notEmpty: true, trim: 50, searchable: true },
      }),
      onlineSearchSchema: new HotSchema({
      }),

      storeName:  'workspacesUsersActivities',

      publicURL: '/config/workspaces/:workspaceId/users/:userId/activities/:id',
      hotExpose: true,
      configStore: { workspaceId: true, userId: true },

      position: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      
    });
    stores.workspacesUsersActivities = new( WorkspacesUsersActivities );

    var WorkspacesContactsCategories = declare( [ HotStore, MultiHomePermsMixin ], {

      schema: new HotSchema({
        name         : { type: 'string', notEmpty: true, trim: 50, searchable: true },
        enabled      : { type: 'boolean', default: true }
      }),

      enabledField: 'enabled',

      onlineSearchSchema: new HotSchema({
        enabled      : { type: 'boolean', default: true }
      }),

      storeName:  'workspacesContactsCategories',

      publicURL: '/config/workspaces/:workspaceId/contactsCategories/:id',
      hotExpose: true,
      configStore: { workspaceId: true },

      position: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
    });
    stores.workspacesContactsCategories = new WorkspacesContactsCategories();

    // Root-level store
    var StatsUses = declare( [ HotStore ], {

      schema: new HotSchema({
        name         : { type: 'string', notEmpty: true, trim: 50, searchable: true },
      }),

      onlineSearchSchema: new HotSchema({
      }),

      storeName:  'statsUses',

      publicURL: '/statsUses/:id',
      hotExpose: true,
      configStore: { },

      position: true,

      hotGlobalBroadcast: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      
    });
    stores.statsUses = new StatsUses();


    var WorkspacesContacts = declare( [ HotStore, MultiHomePermsMixin ],  {

      schema: new HotSchema({
        firstName         : { type: 'string', notEmpty: true, required: false, trim: 50, searchable: true },
        middleName        : { type: 'string', required: false, trim: 50, searchable: true },
        lastName          : { type: 'string', required: false, trim: 50, searchable: true },
        dateOfBirth       : { type: 'date',   required: false, searchable: true },
        isCompany         : { type: 'boolean',required: false, searchable: true },
        contactCategory   : { type: 'id',     required: false, notEmpty: false, searchable: true },

        isStarred         : { type: 'boolean',protected: true, required: false, default: false, searchable: true },

        /* Main info */
        mainAddressId     : { type: 'id', protected: true, required: false },
        mainPhoneNumberId : { type: 'id', protected: true, required: false },
        mainEmailId       : { type: 'id', protected: true, required: false },
        
        /* Linked user */
        userId      : { type: 'id', protected: true, required: false },
      }),

      queryConditions: {
        name: 'or',
        args: [
          { name: 'startsWith', args: [ 'workspacesContactsEmails.email', '#searchAll#' ] },
          { name: 'startsWith', args: [ 'workspacesContactsEmails.street', '#searchAll#' ] }
        ]
      },
      

      onlineSearchSchema: new HotSchema({
        firstName      : { type: 'string' },
        middleName     : { type: 'string' },
        lastName       : { type: 'string' },
        dateOfBirth    : { type: 'date' },
        isCompany      : { type: 'boolean' },
        contactCategory: { type: 'id' },
        isStarred      : { type: 'boolean' },
      
        searchAll : { type: 'string', trim: 20, searchable: true, searchOptions: [
          { field: 'firstName', type: 'startsWith', condition: 'or' },
          { field: 'lastName',  type: 'startsWith', condition: 'or' },
          { field: 'workspacesContactsEmails.email',  type: 'startsWith', condition: 'or' },
          { field: 'workspacesContactsAddresses.street',  type: 'startsWith', condition: 'or' }
        ] },

        searchFrom : { type: 'string', trim: 70, searchable: true, searchOptions: [
          { field: 'workspacesContactsPhoneNumbers.fullNumber',  type: 'eq', condition: 'or' },
          { field: 'workspacesContactsEmails.email',  type: 'eq', condition: 'or' },
        ] },
        
      }),

      sortableFields: [ 'firstName', 'lastName' ],
      defaultSort: { 'lastName': 1 },

      storeName:  'workspacesContacts',

      publicURL: '/workspaces/:workspaceId/contacts/:id',
      hotExpose: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      
      nested: [

        {
          type: 'lookup',
          localField: 'mainEmailId',
          layer: 'workspacesContactsEmails',
          layerField: 'id'
          //join: { 'id' : 'mainEmailId' },
        },

        {
          type: 'lookup',
          localField: 'mainAddressId',
          layer: 'workspacesContactsAddresses',
          layerField: 'id'
          //join: { 'id' : 'mainAddressId' },
        },

        {
          type: 'lookup',
          localField: 'mainPhoneNumberId',
          layer: 'workspacesContactsPhoneNumbers',
          layerField: 'id'
          //join: { 'id' : 'mainPhoneNumberId' },
        },

        {
          layer: 'workspacesContactsAddresses',
          join: { 'contactId': 'id' },
          type: 'multiple'
        },

        {
          layer: 'workspacesContactsEmails',
          join: { 'contactId': 'id' },
          type: 'multiple'
        },

        {
          layer: 'workspacesContactsPhoneNumbers',
          join: { 'contactId': 'id' },
          type: 'multiple'
        },



      ],
      children: true,


    });
    stores.workspacesContacts = new WorkspacesContacts();


    var WorkspacesContactsIsStarred = declare( [ WorkspacesContacts, JsonRestStores.OneFieldStoreMixin ], {
      storeName: 'workspacesContactsIsStarred',
      collectionName: 'workspacesContacts',
      publicURL: '/workspaces/:workspaceId/contacts/isStarred/:id',

      piggyField: 'isStarred',
      hotExpose: true,  
    });
    stores.workspacesContactsIsStarred = new WorkspacesContactsIsStarred();


    var UpdateFirstParentMixin = declare( {

      firstParentStoreField: null,

      _setMain: function( request, cb ){

        cb( null );

        var self = this;

        self.apiGetQuery( { ranges: { limit: 1 }, conditions: { contactId: request.params.contactId } }, function( err, docs ){
          if( err ) return cb( err );

          // Get the document. If it's not set, there is no "main" email addres
          var doc = docs[ 0 ];
          if( ! doc ) return cb( null );

          // Make up the update object
          var updateObject = {};
          updateObject[ self.firstParentStoreField ] = doc.id;

          stores.workspacesContacts.dbLayer.update( { name: 'eq', args: [ 'id', request.params.contactId ] }, updateObject, function( err ){
            if( err ) return cb( err );


            stores.workspacesContacts.apiGet( request.params.contactId, function( err, contact ){
              if( err ) return cb( err );

              // NOTE: I undefine `beforeId` so that `broadcastStoreChanges` doesn't take it from the
              // HTTP headers, as the original call here is on the workspacesContactsEmails store,
              // and the putBefore would be wrong

              // Sends a storeRecordUpdate. Since the update is on fields that are NOT directly editable,
              // it will pass `keepForm` as true, so that editing forms open won't grey out
              stores.workspacesContacts.broadcastStoreChanges( request, 'storeRecordUpdate', contact.id, contact, { tabId: null, keepForm: true, beforeId: undefined }, cb );
            });
          });

        });
      },


      afterEverything: function f( request, method, p, done ){

        var self = this;
        self.inheritedAsync( f, arguments, function( err ){
          if( err ) done( err );

          // Query methods will not affect the main record, so don't do anything
          if( method === 'get' || method === 'getQuery' ) return done( null );

          // Set the main record, passing the request
          self._setMain( request, done );
        });
      },
    });



    var WorkspacesContactsAddresses = declare( [ HotStore, MultiHomePermsMixin, UpdateFirstParentMixin ],  {

      firstParentStoreField: 'mainAddressId',

      schema: new HotSchema({
        label             : { type: 'string', required: false, trim: 64 },
        street            : { type: 'string', required: false, trim: 256 },
        poBox             : { type: 'string', required: false, trim: 64 },
        localArea         : { type: 'string', required: false, trim: 64 },
        city              : { type: 'string', required: false, trim: 64 },
        county            : { type: 'string', required: false, trim: 64 },
        postcode          : { type: 'string', required: false, trim: 10 },
        country           : { type: 'string', required: false, trim: 64 },
      }),

      onlineSearchSchema: new HotSchema({
        label             : { type: 'string' },
        street            : { type: 'string' },
        poBox             : { type: 'string' },
        localArea         : { type: 'string' },
        city              : { type: 'string' },
        county            : { type: 'string' },
        postcode          : { type: 'string' },
        country           : { type: 'string' },
      }),

      storeName:  'workspacesContactsAddresses',

      publicURL: '/workspaces/:workspaceId/Contacts/:contactId/addresses/:id',
      hotExpose: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      
      position: true,
    });
    stores.workspacesContactsAddresses = new WorkspacesContactsAddresses();


    var WorkspacesContactsEmailsBase = declare( [ HotStore, MultiHomePermsMixin ],  {

      schema: new HotSchema({

        id         : { type: 'id', searchable: true },
        workspaceId: { type: 'id', searchable: true },
        contactId  : { type: 'id', searchable: true },

        label      : { type: 'string', searchable: true, required: false, trim: 64 },
        email      : { type: 'string', searchable: true, required: true, notEmpty: true, sharedValidator: 'email', trim: 255, min: 4 },
      }),

      nested: [

        {
          type: 'lookup',
          localField: 'contactId',
          layer: 'workspacesContacts',
          layerField: 'id',
          //join: { 'id' : 'contactId' },
        },

      ],
      storeName:  'workspacesContactsEmailsBase',
      collectionName: 'workspacesContactsEmails',

      idProperty: 'id',

      position: true,
      hotExpose: false,

    });
    stores.workspacesContactsEmailsBase = new WorkspacesContactsEmailsBase();


    var WorkspacesContactsEmailsSearch = declare( [ WorkspacesContactsEmailsBase ],  {

      storeName:  'workspacesContactsEmailsSearch',
      collectionName: 'workspacesContactsEmails',

      publicURL: '/workspaces/:workspaceId/contactEmailsSearch/:id',
      hotExpose: true,

      handleGetQuery: true,      

      onlineSearchSchema: new HotSchema({

        isStarred: {
          type: 'boolean', trim: 20, searchOptions: {
            field: 'contactId.isStarred', condition: 'and'
          }
        },

        searchAll: { type: 'string', trim: 20, searchable: true, searchOptions: [
          { field: 'email',               type: 'startsWith', condition: 'or'  },
          { field: 'contactId.firstName', type: 'startsWith', condition: 'or'  },
          { field: 'contactId.lastName',  type: 'startsWith', condition: 'or'  },
        ] },
      }),

      //sortableFields: [ 'contactId.id', '__position' ],

      defaultSort: { 'contactId.id': 1, __position: 1 },

      // This is here to add `previousContactId` to each record, so that
      // the rendering can be done properly
      afterEverything: function( request, method, p, done ){
 
        // Only affects getQuery
        if( method !== 'getQuery' ) return done( null );

        var queryDocs = p.preparedDocs;

        // Assign null to the previous element
        if( queryDocs.length ) queryDocs[ 0 ].previousContactId = null;

        // Assign previousContactId to the remaining elements
        for( var i = 1, l = queryDocs.length; i < l; i ++){
          queryDocs[ i ].previousContactId = queryDocs[ i - 1 ].contactId;
        }

        done( null );
      }


    });
    stores.workspacesContactsEmailsSearch = new WorkspacesContactsEmailsSearch();


    var WorkspacesContactsEmails = declare( [ WorkspacesContactsEmailsBase, UpdateFirstParentMixin ],  {

      firstParentStoreField: 'mainEmailId',

      storeName:  'workspacesContactsEmails',
      collectionName: 'workspacesContactsEmails',

      publicURL: '/workspaces/:workspaceId/contacts/:contactId/emails/:id',
      hotExpose: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,      

      position: true,

      onlineSearchSchema: new HotSchema({
        label    : { type: 'string', required: false, trim: 64 },
        email    : { type: 'string', required: false, notEmpty: false, trim: 70 },
      }),

      // Don't allow the same email address twice
      afterValidate: function( request, method, p, done ){
        var self = this;

        var body = request.body;

        if( method === 'get' || method === 'getQuery' ) return done( null );

        stores.workspacesContactsEmails.apiGetQuery( { conditions: { email: body.email, contactId: body.contactId } },  function( err, docs ){
          if( err ) return done( err );

          // Filter self out (only need to do it for PUT calls)
          if( method === 'put' ){
            docs = docs.filter( function(i) { return i.id.toString() != body.id.toString() } );
          }

          if( docs.length ){
            var errors = [];
            errors.push( { field: 'email', message: 'Email address already on file' } );
            done( new self.UnprocessableEntityError( { errors: errors } ) );
          } else {
            done( null );
          }
        });
      },

    });
    stores.workspacesContactsEmails = new WorkspacesContactsEmails();


    var WorkspacesContactsPhoneNumbersBase = declare( [ HotStore, MultiHomePermsMixin ],  {
  
      schema: new HotSchema({
        id         : { type: 'id', searchable: true },
        workspaceId: { type: 'id', searchable: true },
        contactId  : { type: 'id', searchable: true },

        label     : { type: 'string', searchable: true, required: false, trim: 64 },
        dialCode  : { type: 'string', searchable: true, required: true, notEmpty: true, trim: 4, min: 1, sharedValidator: 'countryDialCode' },
        number    : { type: 'string', searchable: true, required: true, notEmpty: true, trim: 20, min: 1, sharedValidator: 'phoneNumber', },
        fullNumber: { type: 'string', searchable: true, protected: true, trim: 24 }
      }),

      nested: [

        {
          type: 'lookup',
          localField: 'contactId',
          layer: 'workspacesContacts',
          layerField: 'id'
          //join: { 'id' : 'contactId' },
        },

      ],

      storeName:  'workspacesContactsPhoneNumbersBase',
      collectionName: 'workspacesContactsPhoneNumbers',

      idProperty: 'id',

      position: true,
      hotExpose: false,

      // Makes up fullNumber
      afterCheckPermissions: function( request, method, p, done ){

        // If it's a wrting method, update the protected field fullNumber
        if( method == 'post' || method == 'putNew' || method == 'putExisting' ){
          request.body.fullNumber = request.body.dialCode + request.body.number;
        }

        done( null );
      },

    });
    stores.workspacesContactsPhoneNumbersBase = new WorkspacesContactsPhoneNumbersBase();


   var WorkspacesContactsPhoneNumbersSearch = declare( [ WorkspacesContactsPhoneNumbersBase ],  {

      storeName:  'workspacesContactsPhoneNumbersSearch',
      collectionName: 'workspacesContactsPhoneNumbers',

      publicURL: '/workspaces/:workspaceId/contactPhoneNumbersSearch/:id',
      hotExpose: true,

      handleGetQuery: true,      

      onlineSearchSchema: new HotSchema({

        isStarred: {
          type: 'boolean', trim: 20, searchOptions: {
            field: 'contactId.isStarred', condition: 'and'
          }
        },

        searchAll: { type: 'string', trim: 20, searchable: true, searchOptions: [
          { field: 'number',               type: 'startsWith', condition: 'or'  },
          { field: 'contactId.firstName', type: 'startsWith', condition: 'or'  },
          { field: 'contactId.lastName',  type: 'startsWith', condition: 'or'  },
        ] },
      }),

      defaultSort: { 'contactId.id': 1, __position: 1 },


      // This is here to add `previousContactId` to each record, so that
      // the rendering can be done properly
      afterEverything: function( request, method, p, done ){
 
        // Only affects getQuery
        if( method !== 'getQuery' ) return done( null );

        var queryDocs = p.preparedDocs;

        // Assign null to the previous element
        if( queryDocs.length ) queryDocs[ 0 ].previousContactId = null;

        // Assign previousContactId to the remaining elements
        for( var i = 1, l = queryDocs.length; i < l; i ++){
          queryDocs[ i ].previousContactId = queryDocs[ i - 1 ].contactId;
        }

        done( null );
      }

    });
    stores.workspacesContactsPhoneNumbersSearch = new WorkspacesContactsPhoneNumbersSearch();

    var WorkspacesContactsPhoneNumbers = declare( [ WorkspacesContactsPhoneNumbersBase, UpdateFirstParentMixin ],  {

      firstParentStoreField: 'mainPhoneNumberId',

      storeName:  'workspacesContactsPhoneNumbers',
      collectionName: 'workspacesContactsPhoneNumbers',

      publicURL: '/workspaces/:workspaceId/contacts/:contactId/phoneNumbers/:id',
      hotExpose: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,      

      position: true,

      onlineSearchSchema: new HotSchema({
        label     : { type: 'string' },
        dialCode  : { type: 'string' },
        number    : { type: 'string' },
      }),

    });
    stores.workspacesContactsPhoneNumbers = new WorkspacesContactsPhoneNumbers();


    // Root-level store
    var PhoneNumbers = declare( [ HotStore ], {

      schema: new HotSchema({
        fullNumber       : { type: 'string', required: true,  notEmpty: true, trim: 50, searchable: true, searchOptions: { type: 'contains' },  },
        type             : { type: 'string', required: true,  notEmpty: true, trim: 9, searchable: true, searchOptions: { type: 'eq' }, validator: function( o, v, fieldName ){  if( v !== 'private' && v !== 'shared' && v !== 'available') return "Type must be 'private', 'available' or 'shared' " } },
        provider         : { type: 'string', required: true,  notEmpty: true, trim: 10, searchable: true, searchOptions: { type: 'eq' }, validator: function( o, v, fieldName ){  if( v !== 'twilio' && v !== 'plivo' ) return "Provider must be 'plivo' or 'twilio' " } },
        workspaceId      : { type: 'id', required: false, notEmpty: true, searchable: true, searchOptions: { type: 'eq' }, validator: function( o, v, fieldName ){  if( o.type == 'private' && ! v ) return "You need to specify the workspace ID for private phone numbers" } },
        workspaceIdFilter: { type: 'id', searchable: true, doNotSave: true, searchOptions: [ { field: 'ownedByWorkspaceId', type: 'eq', condition: 'or', }, { field: 'type', type: 'eq', value: 'shared', condition: 'or' } ] }
      }),

      //onlineSearchSchema: new HotSchema({
      //}),

      storeName:  'phoneNumbers',
      publicURL: '/phoneNumbers/:id',
      hotExpose: true,
  
      alwaysRefreshOnChange: true,

      position: true,

      hotGlobalBroadcast: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,  
    });
    stores.phoneNumbers = new PhoneNumbers();

    // Plivo config store
    var PlivoConfig = declare( [ HotStore ], {

      schema: new HotSchema({
        account         : { type: 'string', notEmpty: false, trim: 50, searchable: true },
        token           : { type: 'string', notEmpty: false, trim: 50, searchable: true },        
      }),

      onlineSearchSchema: new HotSchema({
      }),

      storeName:  'plivoConfig',
      publicURL: '/config/plivoConfig/:globalId',
      hotExpose: true,
      configStore: { globalId: true },

      position: true,

      hotGlobalBroadcast: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      
    });
    stores.plivoConfig = new PlivoConfig();

    var WorkspacesEmailConfig = declare( [ HotStore, MultiHomePermsMixin ], {

      schema: new HotSchema({
        systemName  : { type: 'string', required: false, default: "Email system", notEmpty: true, trim: 70},
        systemEmail : { type: 'string', required: false, default: "youremail@example.com", sharedValidator: 'email', notEmpty: true, trim: 255},
        smtpServer      : { type: 'string', required: false,  trim: 256, },
        smtpPort        : { type: 'number', required: true, default: '586' },        
        smtpLogin       : { type: 'string', required: false,  trim: 256, },
        smtpPassword    : { type: 'string', required: false,  trim: 256, },

        imapServer      : { type: 'string', required: false,  trim: 256, },
        imapPort        : { type: 'number', required: true, default: '993' },        
        imapLogin       : { type: 'string', required: false,  trim: 256, },
        imapPassword    : { type: 'string', required: false,  trim: 256, },
        imapPollInterval: { type: 'number', required: true, default: '300', min: 60, max: 600 },

      }),

      onlineSearchSchema: new HotSchema({
      }),

      storeName:  'workspacesEmailConfig',

      publicURL: '/config/workspacesEmailConfig/:workspaceId',
      hotExpose: true,
      configStore: { workspaceId: true },

      handlePut: true,
      handleGet: true,

      prepareBeforeSend: function( request, method, doc, cb ){
        var doc = this._co( doc );

        doc.id = doc.workspaceId;
        cb( null, doc );
      },

    });
    stores.workspacesEmailConfig = new WorkspacesEmailConfig();

    var WorkspacesSmsConfig = declare( [ HotStore, MultiHomePermsMixin ], {

      schema: new HotSchema({
        phoneNumberId : { searchable: true, type: 'id', required: false },
      }),

      onlineSearchSchema: new HotSchema({
      }),

      nested: [
        {
          type: 'lookup',
          localField: 'phoneNumberId',
          layer: 'phoneNumbers',
          layerField: 'id'
          //join: { 'id' : 'phoneNumberId' },
        },
      ],

      storeName:  'workspacesSmsConfig',

      publicURL: '/config/workspacesSmsConfig/:workspaceId',
      hotExpose: true,
      configStore: { workspaceId: true },

      handlePut: true,
      handleGet: true,
    });
    stores.workspacesSmsConfig = new WorkspacesSmsConfig();


    // YOU ARE HERE
    // PSEUDO-STORE, allows creation of contacts with attached phone number
    // or email address in one go. It also tries to complete the basic information
    // (name, lastname) if email address.
    var ContactsCreator = declare( JsonRestStores, {
  
      // COMMON
      schema: new SimpleSchema({
        type    :      { type: 'string'},
        from    :      { type: 'blob' }, // This is 'blob' as SimpleSchema has numbers for IDs by default
      }),
    
      storeName:  'ContactsCreator',
  
      publicURL: '/workspaces/:workspaceId/contactsCreator/:id',
      hotExpose: true,
      type: 'uncached',

      handlePost: true,

      
      implementFetchOne: function( request, done ){
  
        var messages = [];
        var self = this;
  
  
        // If it's not a remote call, always return empty result
        if( ! request.remote ) return done( null, { messages: [] } );
  
        var headersWorkspaceId = request._req.headers[ 'x-hotplate-workspaceid' ];
  
        // User is not logged in -- goodbye
        if( ! request._req.session.loggedIn || ! request._req.session.userId ){
          debug("A non-logged in user tried to fetch tabId %s for workspaceId %s, denying...", request.params.tabId, headersWorkspaceId );
          return done( new self.UnauthorizedError() );
        }
  
        debug("Looking for tab %s owned by user %s, x-workspaceId is %s", request.params.tabId, request._req.session.userId, headersWorkspaceId );
  
        // Return all messages for that tab, REMOVING after fetching
        stores.tabs.apiGetQuery( { conditions: { id: request.params.tabId, userId: request._req.session.userId, fromLastSync: new Date() - TABLIFESPAN } }, function( err, tab ){
          if( err ){
            done( err );
          } else {
  
  
            debug("Returned:");
            debug( tab );
            if( tab.length == 0 ){
  
              debug("Tab was NOT present. Trying to understand if I should create one");
  
              // At this point, the tab wasn't found. If workspaceId was passed via headers,
              // the person will be returned the configuration for that workspace. We need to check
              // that the user actually has access to that workspaceId.
  
              hotCoreStoreRegistry.getAllStores( function( err, storesData ){
                if( err ){
                  done( err );
                } else {
                  debug("Checking that user has access to the workspaceId she is trying to register for");
                  storesData.usersWorkspaces.apiGetQuery( { conditions: { userId: request._req.session.userId, workspaceId: headersWorkspaceId } }, function( err, uwDocs){
                    if( err ){
                      done( err );
                    } else {
                      if( uwDocs.length == 0 ){
                        debug("No access -- user needs to (re?)login!");
                        done( new self.UnauthorizedError() );
                      } else {
                 
      
                        debug("OK, access is cleared, creating the tab for the user...");
                        debug( request._req.session.userId );
                        stores.tabs.apiPost( { userId: request._req.session.userId }, { killComet: true }, function( err, tab ){
                          if( err ){
                             done( err );
                          } else {
      
                            
                            debug("...and ALSO returning the workspace configuration for that userId");
                            hotCoreStoreConfig.getConfigRecords( headersWorkspaceId, request._req.session.userId, function( err, storeRecords ){
                              if( err ){
                                done( err );
                              } else {
                                done( null, { messages: [ { fromUserId: request._req.session.userId, message: { type: 'resetStores', tabId: tab.id, storeRecords: storeRecords } } ] } );
                              };
                            });
      
                          }
                        }); // Tabs.Post()
      
      
                      }
                    }
                  });//UsersWorkspaces.GetQuer ()
                }
              });
  
  
            } else {
  
              // Write the new access time onto the tab's record; 
              tab = tab[ 0 ];
              tab.lastSync = new Date();
              stores.tabs.apiPut( tab.id, tab, { killComet: true }, function( err, tab ){
                if( err ){
                  done( err );
                } else {
  
                  // Return all messages for that tab, REMOVING after fetching
                  stores.tabMessages.apiGetQuery( { sort: { added: 1 }, conditions: { tabId: request.params.tabId, fromAdded: new Date() - TABLIFESPAN }, delete: true }, function( err, tabMessages ){
                    if( err ){
                      done( err );
                    } else {
           
                      tabMessages.forEach( function( tabMessage ){
                        // delete tabMessage._\id;
                        delete tabMessage.messageId;
                        delete tabMessage.tabId;
  
                        messages.push( tabMessage);
                      });
                      done( null, { messages: messages } );
                    }
                  });
                }
  
              });
  
             }
          };
        });
      
      },
  
    });
    stores.contactsCreator = new ContactsCreator();


    // Make up stores derived from hotCoreTransport
    hotplate.hotEvents.emitModule( 'stores', 'hotCoreTransport', function( err, results){
      if( err ) return done( err );
    
      var messages = results.onlyResults()[ 0 ]['messages'];  

      var OnlineMessages = declare( [ messages.constructor, s.HotStoreMixin, MultiHomePermsMixin  ], {
        storeName: 'onlineMessages',
        collectionName: 'messages',

        handleGet: true,
        hotExpose: true,
        publicURL: '/messages/:id',
      });
      stores.onlineMessages = new OnlineMessages();

      done( null, stores );

    })

  });

}));


// Simply activate path to client files
hotplate.hotEvents.on( 'clientPath', 'bd', function( done ){
  done( null, path.join(__dirname, '../client') );
} )

// Define which paths within clientPath will need to be rendered, and with which options
hotplate.hotEvents.on( 'clientPathRender', 'bd', function( done ){
  done( null, [
    {
      'templates/BookingDojo.jade': { name: 'Tony' },
      'templates/AnotherBookingDojo.jade': {},
    }
  ] );
});



hotplate.hotEvents.on( 'dojoModulesPerPage', 'bd', function( req, pageName, done ){

  switch( pageName ){

    case 'hotDojoAppContainer/container':
      done( null, [ 'bdMain' ] );
    break;

    default:
      done( null, [ ] );
    break;
  }

});


hotplate.hotEvents.on( 'pageElements', 'bd', function( done ){
    done( null, { titleWords: [ "Booking Dojo" ] } );
})

hotplate.hotEvents.on( 'pageElementsPerPage', 'bd', function( req, pageName, done ){

  switch(pageName){

    case 'hotDojoAppContainer/container':

      // Sending the page out
      done( null, {
        csses: ['bdMain.css' ],
        titleWords: [ "Application" ],
      });

    break;

   default:
      done( null, {} );
    break;
  }
});

hotplate.hotEvents.on( 'sharedFunctions', 'bd', hotplate.cachable( function( done ) {

  var result = {};

  result.phoneNumberValidator = function( number ){
    if( number === false ) return "Phone number invalid, only numbers and spaces allowed";
    return number.match( /^[0-9 ]+$/ );
  };

  result.renderContactName = function( c ){
    return ( c.firstName ? c.firstName + ' ' : '' ) +
           ( c.lastName ? c.lastName + ' ' : '' );
  };


  done( null, result );
}));
