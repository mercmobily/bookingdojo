var 
  dummy

, hotplate =  require('hotplate')
, path = require('path')

, Store = require('jsonreststores-mongo')

, async = require('async')
, util = require('util')
, mongoWrapper = require('mongowrapper')
, db = hotplate.get('db')
, declare = require( 'simpledeclare' )

, ObjectId = mongoWrapper.ObjectId
, Schema = Store.Schema

;

app = hotplate.app;


Error.stackTraceLimit = 50;

exports.hotHooks = hooks = {}

hooks.creatingUser = function( done, u, body ){
  u.settings = u.settings || {};
  u.settings.email = u.registerEmail; 

  u.settings.name = body.name;
  u.settings.surname = body.surname;

  done( null );
}

hooks.creatingWorkspace = function( done, u, w ){

  w.access[0].settings = {};
  w.access[0].settings.localEmail = u.registerEmail; 

  w.settings = w.settings || {};
  w.settings.tag = "Your tagline here";
  w.settings.longName = "Your workspace's long name"

  done( null );
}


hooks.createWorkspaceAnonSchema = function( done, schema ){

  schema.structure.name    = { type: 'string', notEmpty: true, required: true, trim: 45 };
  schema.structure.surname = { type: 'string', notEmpty: true, required: true, trim: 60 };

  done( null );
}

hooks.init = function( done ){
  done( null );
}

hooks.run = function( done ){

  var resUtils = hotplate.getModule('hotCoreResUtils');
  var messages = hotplate.getModule('hotMongoCometMessages');



  var HotStore = declare( Store, {

    db: db,

    killComet: false,

    afterPutExisting: function( req, body, doc, docAfter, fullDoc, fullDocAfter, overwrite ){

      var self = this;

      this.inherited( arguments );

      if( ! self.killComet ){

        // Broadcast the change
        messages.sendToTabsOfWorkspace(

          // These ones never change
          req.application.workspace._id,
	  ObjectId( req.body._tabId ),
          req.application.user._id,
          'storeUpdate',

          // These ones do change: it's the message to broadcast
          { storeName: self.storeName,
            objectId: doc._id,
            object: doc,
            remote: true
          } );
      }
    },    

    afterPutNew: function( req, body, doc, fullDoc, overwrite  ){

      var self = this;

      this.inherited( arguments );


      if( ! self.killComet ){

        // Broadcast the change
        messages.sendToTabsOfWorkspace(

          // These ones never change
          req.application.workspace._id,
          fullDoc._tabId,
          req.application.user._id,
          'storeUpdate',

          // These ones do change: it's the message to broadcast
          { storeName: self.storeName,
            objectId: doc._id,
            object: doc,
            remote: true
          } );
      }
    },    
  });

 
  var OptionsStore = declare( Store,  {
    storeName: 'options',
    db: db,
    schema: new Schema({
      _id   : { type: 'id', required: true },
      _tabId: { type: 'id', required: true, doNotSave: true },

      name  : { type: 'string', notEmpty: true, trim: 50, searchable: true, sortable: true, searchPartial: true },
      age   : { type: 'number', notEmpty: true , searchable: true, sortable: true },
    }),

    paramIds: [ 'optionId' ],
    handleGet: true,
    handleGetQuery: true,
    handlePut: true,
    handlePost: true,
    echoAfterPutNew: true,
    echoAfterPutExisting: true,
    echoAfterPost: true,
    echoAfterPostAppend: true,

    allDbExtrapolateDoc: function( fullDoc, res, cb ){
      var d = {};
      d.name = fullDoc.name;
      cb( null, d );
    },
    getDbPrepareBeforeSend: (function(){
      var i = 0;

      return function( doc, cb ){
        doc.CAZ = i ++;
        cb( null, doc ) 
      }
    })(),
  });

  // app.get( '/call/:workspaceIdCall/Options/:optionId', JsonRestStores.Store.makeGet( OptionsStore ) );
  
  Store.make.All( app,  '/call/:workspaceIdCall/Options/', ':optionId', OptionsStore );

  var val = function(v, k, schema ){
    //console.log("Validator called for: ");
    //console.log( v );
    //console.log("k: ");
    //console.log( k );
    //console.log("this: ");
    //console.log( this );
    //console.log("Schema: ");
    //console.log( schema );
    return;
    return "Error something or other";
  }

  var UserConfig = declare( HotStore, {

    // COMMON
    schema: new Schema({
      _id     : { type: 'id', isRequired: true },
      _tabId  : { type: 'id', doNotSave: true  },

      email   : { type: 'string', notEmpty: true, trim: 70, min: 10 },
      surname : { type: 'string', notEmpty: true, trim: 10 },
      name    : { type: 'string', notEmpty: true, validate: val, noshit: true, trim: 5 },
    },
    {
      validate: function( schema, errors, cb ){
        if( this.name == 'Tony' ){
          cb( new Error("NO, TONY NO!" ) );
        } else {
          cb( null );
        }
      },


    } ),

    handlePut: true,
    handleGet: true,

    collectionName: 'users',

    storeName:  'userConfig',
    paramIds: [ 'userId' ],

    allDbExtrapolateDoc: function( fullDoc, req, cb ){
      var d = fullDoc.settings;
      d._id = fullDoc._id;
      cb( null, d );
    },

    // Permissions for the get
    checkPermissionsGet: function( req, doc, fullDoc, cb ) {
      cb( null, req.application.workspace.access.filter( function(o){ return o._id.toString() === doc._id.toString(); } ).length  );
    },
  
    // Permissions to save data
    checkPermissionsPutExisting: function( req, doc, fullDoc, cb ) {
      // TODO: implement this
      cb( null, true );
    },

    // Nobody cannnot create new records -- they need to exist beforehand
    checkPermissionsPutNew: function( req, cb){  cb( null, false );  },

    postDbUpdatePrefix: 'settings.',

  });

  Store.make.All( app, '/call/:workspaceIdCall/userConfig/', ':userId', UserConfig );
 

  var UserConfigNoWorkspace = declare( UserConfig, {

    // Redefine the permission calls 
    checkPermissionsGet: function(  req, doc, fullDoc, cb ){
      cb( null,  req.session.userId.toString() == req.params.userId );
    },
    checkPermissionsPutExisting: function( req, doc, fullDoc, cb ) {
      cb( null, ! req.session.userId.toString() == doc._id.toString() );
    },

    killComet: true,
  });

  Store.make.All( app, '/call/userConfigNoWorkspace/', ':userId', UserConfigNoWorkspace );
  

  var WorkspaceConfig = declare( HotStore, {

    schema: new Schema({
      _id     : { type: 'id', isRequired: true },
      _tabId  : { type: 'id', doNotSave: true  },

      longName: { type: 'string', notEmpty: true, trim: 35 },
      tag     : { type: 'string', notEmpty: true, notEmpty: true, trim: 70 },
    }),
    collectionName: 'workspaces',
    storeName:  'workspaceConfig',
    paramIds: [ 'workspaceId' ],

    handlePut: true,
    handleGet: true,

    allDbExtrapolateDoc: function( fullDoc, req, cb ){
      var d = fullDoc.settings;
      d._id = fullDoc._id;
      cb( null, d );
    },

    postDbUpdatePrefix: 'settings.',

    checkPermissionsGet: function(  req, doc, fullDoc, cb ){
      cb( null, resUtils.currentUserInWorkspaceAccess( req, fullDoc ) );
    },

    checkPermissionsPutExisting: function( req, doc, fullDoc, cb ) {
      cb( null, resUtils.currentUserInWorkspaceAccess( req, fullDoc ) );
    },

    // Nobody cannnot create new records -- they need to exist beforehand
    checkPermissionsPutNew: function( req, cb){  cb( null, false );  },

  });

  Store.make.All( app, '/call/:workspaceIdCall/workspaceConfig/', ':workspaceId', WorkspaceConfig );

  

  var AccessConfig = declare( HotStore, {

    // COMMON

    schema: new Schema({
      _id       : { type: 'id', isRequired: true },
      _tabId    : { type: 'id', doNotSave: true  },

      localEmail: { type: 'string', notEmpty: true, trim: 35 },
    }),

    collectionName: 'workspaces',
    storeName:      'accessConfig',
    paramIds:       [ 'userId' ],

    handlePut: true,
    handleGet: true,

    allDbFetch: function( req, cb ){
      this.collection.findOne( { _id: req.application.workspace._id , 'access._id': req.params.userId }, cb );
    },

    allDbExtrapolateDoc: function( fullDoc, req, cb ){
      var d = fullDoc.access.filter(
        function(o) { return o._id.toString() === req.params.userId.toString() }
      )[0].settings;

      d._id = req.params.userId;
      cb( null, d );
    },
    
    checkPermissionsGet:function( req, doc, fullDoc, cb ) {
      cb( null, true );
    },

    checkPermissionsPutExisting:function( req, doc, fullDoc, cb ) {
      cb( null, req.application.user._id.toString() == doc._id.toString() );
    },

    postDbUpdatePrefix: 'access.$.settings.',

    putDbUpdate: function( body, req, doc, fullDoc, cb ){

      var updateObject = this.postDbMakeUpdateObject( body, { '_id': true } );

      this.collection.findAndModify(
        {  _id: req.application.workspace._id , access: { $elemMatch: { _id: req.params.userId } } }, 
        { },
        updateObject, 
        { new: true }, 
        cb );
    },

  } );

  Store.make.All( app, '/call/:workspaceIdCall/accessConfig/', ':userId', AccessConfig );

  done( null );
}


hooks.pageElementsPerPage = function( done, elements, req, pageName ){


  switch(pageName){


    case 'hotDojoAppContainer/container':

      var userConfig, accessConfig, workspaceConfig;

      workspaceConfig     = req.application.workspace.settings;
      workspaceConfig._id = req.application.workspace._id;

      userConfig          = req.application.user.settings;
      userConfig._id      = req.application.user._id;

      accessConfig        = req.application.access.settings;
      accessConfig._id    = req.application.user._id;

      // Sending the page out
      done( null, {
              moduleName: 'bd', result: {
                jses:  ['bdMain.js', 'jade.js' ],
                csses: ['bdMain.css'],
                vars: [
                  { name: 'userConfig',      value: userConfig },
                  { name: 'accessConfig',    value: accessConfig },
                  { name: 'workspaceConfig', value: workspaceConfig } 
                ], 
              }
      });
    break;

    // Add an extra div to the "No workspaces to pick!" page, so that
    // a user can click on their config if they like (they are logged in after all)
    case 'hotDojoAuth/pickButEmptyPage':

      done( null, {
               moduleName: 'bd', result: {
                 body: elements.body.replace('</div></body>', '<div id="userConfig"></div></div></body>'),
                 jses: ['mainPickEnrich.js', 'jade.js'],
              }
      });
    break;

    case 'hotDojoAuth/registerPage':
      done( null, {
               moduleName: 'bd', result: {
                 jses: ['mainChangeRegisterForm.js'],
              }
      });
    break;

    default:
      done( null, { moduleName: 'bd', result: {} }  );
    break;
  }
}


// Simply activate path to client files
hooks.clientPaths = function( done ){
  done( null, { moduleName: 'bd', result: [ path.join(__dirname, '../client') ] } );
}


hooks.stores = function( done ){
  done( null, {
    accessConfig         : { target: '/call/:workspaceIdCall/accessConfig/',    idProperty: '_id', sortParam: 'sortBy', },
    workspaceConfig      : { target: '/call/:workspaceIdCall/workspaceConfig/', idProperty: '_id', sortParam: 'sortBy', },
    userConfig           : { target: '/call/:workspaceIdCall/userConfig/',      idProperty: '_id', sortParam: 'sortBy', },
    userConfigNoWorkspace: { target: '/call/userConfigNoWorkspace/',            idProperty: '_id', sortParam: 'sortBy', },
    options              : { target: '/call/:workspaceIdCall/Options/',         idProperty: '_id', sortParam: 'sortBy', },
  });
}


hooks.sharedFunctions = function( done ) {
  var result = {};
  done( null, { moduleName: 'bd', result: result } );
}




