var
  dummy

, hotplate =  require('hotplate')
, path = require('path')
, async = require('async')
, debug = require('debug')('bd')
, emailaddresses = require( 'email-addresses')

, declare = require( 'simpledeclare' )

, hotCoreJsonRestStores = hotplate.require('hotCoreJsonRestStores')
, hotCoreMultiHome = hotplate.require('hotCoreMultiHome')
, hotCoreStoreRegistry = hotplate.require( 'hotCoreStoreRegistry' )
, hotCoreServerLogger = hotplate.require( 'hotCoreServerLogger' )
, logger = hotCoreServerLogger
, JsonRestStores = require( 'jsonreststores' )
, SimpleSchema = require( 'simpleschema' )
;

JsonRestStores.artificialDelay = 500;

// Hooks to manage SMSes
require('./messagesManager.js')

// Hooks to manage the stores test (to be eradicated)
require('./storesTest.js')

require('./dialCodes.js')


hotplate.hotEvents.onCollect( 'run', 'bd', hotplate.cachable( function( done ){

  hotCoreStoreRegistry.getAllStores( function( err, storeRegistry ){
    if( err ) return done( err );

    // Every time a workspace is added a contact is also added automatically
    // for that workspace, linking to the owner
    storeRegistry.workspacesUsersBase.dbLayer.onCollect( 'insert', function( fetchedRecord, record, options, done ){

      storeRegistry.workspacesContacts.dbLayer.insert( { userId: record.userId, workspaceId: fetchedRecord.workspaceId }, function( err ){
        if( err ) return done( err );

        done();
      });

    });
    
    // End of Hotplate's 'run' hook
    done( null );
  });

}));


hotplate.hotEvents.onCollect( 'stores', 'bd', hotplate.cachable( function( done ){

  var stores = {};

  var MultiHomePermsMixin = hotCoreMultiHome.MultiHomeBasicPermissionsMixin;
  var PrivateUserDataMixin = hotCoreJsonRestStores.PrivateUserDataPermissionsMixin;

  hotCoreJsonRestStores.get( function( err, s ){
    if( err ) return done( err );

    var HotStore = s.HotStore;
    var HotSchema = s.HotSchema;
    var BasicDbStore = s.BasicDbStore;
    var BasicSchema = s.BasicSchema;

    var UsersInfo = declare( [ HotStore, MultiHomePermsMixin, PrivateUserDataMixin ], {

      schema: new HotSchema({
        email       :  { type: 'string', required: true, default: "youremail@example.com", notEmpty: true, sharedValidator: 'email', trim: 255, min: 4 },
        //surname     :  { type: 'string', required: true, default: "Your surname", notEmpty: true, trim: 10 },
        //name        :  { type: 'string', required: true, default: "Your name", notEmpty: true, trim: 50 },
      }),

      onlineSearchSchema: new HotSchema({
        email     : { type: 'string' },
        //surname   : { type: 'string' },
        //name      : { type: 'string' },
      }),

      handlePut: true,
      handleGet: true,

      storeName:  'usersInfo',

      publicURL: '/config/users/:userId',
      hotExpose: true,
      configStore: { userId: true },
    });
    stores.usersInfo = new UsersInfo();


    var UsersInterests = declare( [ HotStore, MultiHomePermsMixin, PrivateUserDataMixin ], {

      schema: new HotSchema({
        name          : { type: 'string', required: true, trim: 35, searchable: true },
      }),

      onlineSearchSchema: new HotSchema({
      }),

      storeName: 'usersInterests',

      publicURL: '/config/users/:userId/interests/:id',
      hotExpose: true,
      configStore: { userId: true },

      defaultNewToStart: true,

      position: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      
    });
    stores.usersInterests = new UsersInterests();


    var WorkspacesInfo = declare( [ HotStore, MultiHomePermsMixin ], {

      schema: new HotSchema({
        longName: { 
          type: 'string', 
          required: true, 
          default: "Workspace's long name", 
          notEmpty: true, 
          trim: 35, 
          searchable: true
        },
        tag: { 
          type: 'string', 
          required: true, 
          default: "Workspace's tag line",
          notEmpty: true,
          trim: 70,
          searchable: true
        },
        statsUse: {
          type: 'id',
          required: false,
          notEmpty: false
        },
        countryDialCodeDefault: { 
          type: 'string',
          required: false,
          notEmpty: true,
          trim: 4,
          min: 1,
          sharedValidator: 'countryDialCode'
        },
      }),

      onlineSearchSchema: new HotSchema({
      }),

      storeName:  'workspacesInfo',

      publicURL: '/config/workspacesInfo/:workspaceId',
      hotExpose: true,
      configStore: { workspaceId: true },

      handlePut: true,
      handleGet: true,
    });
    stores.workspacesInfo = new WorkspacesInfo();


    var WorkspacesUsersInfo = declare( [ HotStore, MultiHomePermsMixin, PrivateUserDataMixin ], {

      schema: new HotSchema({
        setting1          : { type: 'string',  required: true, default: 'Default 1', notEmpty: true,  trim: 35 },
        orderByNameDefault: { type: 'boolean', required: true, default: true },
        notificationsEmailAddress  : { type: 'id',  required: false },
      }),

      onlineSearchSchema: new HotSchema({
      }),

      storeName: 'workspacesUsersInfo',

      publicURL: '/config/workspaces/:workspaceId/users/:userId',
      hotExpose: true,
      configStore: { workspaceId: true, userId: true },

      handlePut: true,
      handleGet: true,

      nested: [
        {
          layer: 'workspacesContacts',
          join: { userId: 'userId' },
          type: 'multiple',
        },
      ],

    });
    stores.workspacesUsersInfo = new WorkspacesUsersInfo();


    var WorkspacesUsersActivities = declare( [ HotStore, MultiHomePermsMixin, PrivateUserDataMixin ], {

      schema: new HotSchema({
        name        : { type: 'string', notEmpty: true, trim: 50, searchable: true },
      }),
      onlineSearchSchema: new HotSchema({
      }),

      storeName:  'workspacesUsersActivities',

      publicURL: '/config/workspaces/:workspaceId/users/:userId/activities/:id',
      hotExpose: true,
      configStore: { workspaceId: true, userId: true },

      position: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      
    });
    stores.workspacesUsersActivities = new( WorkspacesUsersActivities );

    var WorkspacesContactsCategories = declare( [ HotStore, MultiHomePermsMixin ], {

      schema: new HotSchema({
        name         : { type: 'string', notEmpty: true, trim: 50, searchable: true },
        enabled      : { type: 'boolean', default: true }
      }),

      enabledField: 'enabled',

      onlineSearchSchema: new HotSchema({
        enabled      : { type: 'boolean', default: true }
      }),

      storeName:  'workspacesContactsCategories',

      publicURL: '/config/workspaces/:workspaceId/contactsCategories/:id',
      hotExpose: true,
      configStore: { workspaceId: true },

      position: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
    });
    stores.workspacesContactsCategories = new WorkspacesContactsCategories();

    // Root-level store
    var StatsUses = declare( [ HotStore ], {

      schema: new HotSchema({
        name         : { type: 'string', notEmpty: true, trim: 50, searchable: true },
      }),

      onlineSearchSchema: new HotSchema({
      }),

      storeName:  'statsUses',

      publicURL: '/statsUses/:id',
      hotExpose: true,
      configStore: { },

      position: true,

      hotGlobalBroadcast: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      
    });
    stores.statsUses = new StatsUses();


    var WorkspacesContacts = declare( [ HotStore, MultiHomePermsMixin ],  {

      schema: new HotSchema({
        firstName         : { type: 'string', notEmpty: true, required: false, trim: 50, searchable: true },
        middleName        : { type: 'string', required: false, trim: 50, searchable: true },
        lastName          : { type: 'string', required: false, trim: 50, searchable: true },
        dateOfBirth       : { type: 'date',   required: false, searchable: true },
        isCompany         : { type: 'boolean',required: false, searchable: true },
        contactCategory   : { type: 'id',     required: false, notEmpty: false, searchable: true },

        isStarred         : { type: 'boolean', protected: true, required: false, default: false, searchable: true },

        /* Main info */
        mainAddressId     : { type: 'id', protected: true, required: false },
        mainPhoneNumberId : { type: 'id', protected: true, required: false },
        mainEmailId       : { type: 'id', protected: true, required: false },
        
        /* Linked user */
        userId      : { type: 'id', protected: true, required: false },
      }),

      onlineSearchSchema: new HotSchema({
        searchAll  : { type: 'string', trim: 20  },
        searchFrom : { type: 'string', trim: 70  },
        isStarred  : { type: 'boolean' }, 
      }),

      queryConditions: {
        type: 'and',
        args: [

          {
            ifDefined: 'searchAll',
            type: 'or',
            args: [
              { type: 'startsWith', args: [ 'firstName', '#searchAll#' ] },
              { type: 'startsWith', args: [ 'lastName', '#searchAll#' ] },
              { type: 'startsWith', args: [ 'workspacesContactsEmails.email', '#searchAll#' ] },
              { type: 'startsWith', args: [ 'workspacesContactsAddresses.street','#searchAll#' ] },
            ]
          },
          
          { 
            type: 'eq', 
            args: [ 'isStarred','#isStarred#' ]
          },
          {
            ifDefined: 'searchFrom',
            type: 'or',
            args: [
              { type: 'eq', args: [ 'workspacesContactsPhoneNumbers.fullNumber', '#searchFrom#' ] },
              { type: 'eq', args: [ 'workspacesContactsEmails.email', '#searchFrom#' ] },
            ]
          },
        ]
      },

      sortableFields: [ 'firstName', 'lastName' ],
      defaultSort: { 'lastName': 1 },

      storeName:  'workspacesContacts',

      publicURL: '/workspaces/:workspaceId/contacts/:id',
      hotExpose: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      
      nested: [

        {
          type: 'lookup',
          localField: 'mainEmailId',
          layer: 'workspacesContactsEmails',
          layerField: 'id'
          //join: { 'id' : 'mainEmailId' },
        },

        {
          type: 'lookup',
          localField: 'mainAddressId',
          layer: 'workspacesContactsAddresses',
          layerField: 'id'
          //join: { 'id' : 'mainAddressId' },
        },

        {
          type: 'lookup',
          localField: 'mainPhoneNumberId',
          layer: 'workspacesContactsPhoneNumbers',
          layerField: 'id'
          //join: { 'id' : 'mainPhoneNumberId' },
        },

        {
          layer: 'workspacesContactsAddresses',
          join: { 'contactId': 'id' },
          type: 'multiple'
        },

        {
          layer: 'workspacesContactsEmails',
          join: { 'contactId': 'id' },
          type: 'multiple'
        },

        {
          layer: 'workspacesContactsPhoneNumbers',
          join: { 'contactId': 'id' },
          type: 'multiple'
        },

      ],
      children: true,
    });
    stores.workspacesContacts = new WorkspacesContacts();


    var WorkspacesContactsIsStarred = declare( [ WorkspacesContacts, JsonRestStores.OneFieldStoreMixin ], {
      storeName: 'workspacesContactsIsStarred',
      collectionName: 'workspacesContacts',
      publicURL: '/workspaces/:workspaceId/contacts/isStarred/:id',

      piggyField: 'isStarred',
      hotExpose: true,  
    });
    stores.workspacesContactsIsStarred = new WorkspacesContactsIsStarred();


    var UpdateFirstParentMixin = declare( {

      firstParentStoreField: null,

      _setMain: function( request, cb ){

        var self = this;

        self.dbLayer.selectByHash( { ranges: { limit: 1 }, conditions: { contactId: request.params.contactId } }, function( err, docs ){
          if( err ) return cb( err );

          // Get the document. If it's not set, there is no "main" email address
          var doc = docs[ 0 ];
          if( ! doc ) return cb( null );

          // Make up the update object
          var updateObject = {};
          updateObject[ self.firstParentStoreField ] = doc.id;

          stores.workspacesContacts.dbLayer.update( { type: 'eq', args: [ 'id', request.params.contactId ] }, updateObject, function( err, n ){
            if( err ) return cb( err );


            stores.workspacesContacts.dbLayer.selectById( request.params.contactId, function( err, contact ){
              if( err ) return cb( err );

              // NOTE: I UNdefine `beforeId` so that `broadcastStoreChanges` doesn't take it from the
              // HTTP headers, as the original call here is on the workspacesContactsEmails store,
              // and the putBefore would be wrong

              // Sends a storeRecordUpdate. Since the update is on fields that are NOT directly editable,
              // it will pass `keepForm` as true, so that editing forms open won't grey out
              stores.workspacesContacts.broadcastStoreChanges( request, 'storeRecordUpdate', contact.id, contact, { tabId: null, keepForm: true, beforeId: undefined }, cb );
            });
          });

        });
      },


      afterEverything: function f( request, method, done ){

        var self = this;
        self.inheritedAsync( f, arguments, function( err ){
          if( err ) done( err );

          // Query methods will not affect the main record, so don't do anything
          if( method === 'get' || method === 'getQuery' ) return done( null );

          // Set the main record, passing the request
          self._setMain( request, done );
        });
      },
    });


    var WorkspacesContactsAddresses = declare( [ HotStore, MultiHomePermsMixin, UpdateFirstParentMixin ],  {

      firstParentStoreField: 'mainAddressId',

      schema: new HotSchema({
        label             : { type: 'string', required: false, trim: 64 },
        street            : { type: 'string', required: false, trim: 256 },
        poBox             : { type: 'string', required: false, trim: 64 },
        localArea         : { type: 'string', required: false, trim: 64 },
        city              : { type: 'string', required: false, trim: 64 },
        county            : { type: 'string', required: false, trim: 64 },
        postcode          : { type: 'string', required: false, trim: 10 },
        country           : { type: 'string', required: false, trim: 64 },
      }),

      onlineSearchSchema: new HotSchema({
        label             : { type: 'string' },
        street            : { type: 'string' },
        poBox             : { type: 'string' },
        localArea         : { type: 'string' },
        city              : { type: 'string' },
        county            : { type: 'string' },
        postcode          : { type: 'string' },
        country           : { type: 'string' },
      }),

      storeName:  'workspacesContactsAddresses',

      publicURL: '/workspaces/:workspaceId/Contacts/:contactId/addresses/:id',
      hotExpose: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      
      position: true,
    });
    stores.workspacesContactsAddresses = new WorkspacesContactsAddresses();


    var WorkspacesContactsEmailsBase = declare( [ HotStore, MultiHomePermsMixin ],  {

      schema: new HotSchema({

        id         : { type: 'id', searchable: true },
        workspaceId: { type: 'id', searchable: true },
        contactId  : { type: 'id', searchable: true },

        label      : { type: 'string', searchable: true, required: false, trim: 64 },
        email      : { type: 'string', searchable: true, required: true, notEmpty: true, sharedValidator: 'email', trim: 255, min: 4 },
      }),

      nested: [

        {
          type: 'lookup',
          localField: 'contactId',
          layer: 'workspacesContacts',
          layerField: 'id',
        },

      ],
      storeName:  'workspacesContactsEmailsBase',
      collectionName: 'workspacesContactsEmails',

      idProperty: 'id',
      //paramIds: [ 'workspaceId', 'contactId', 'id' ],

      position: true,
      hotExpose: false,

    });
    stores.workspacesContactsEmailsBase = new WorkspacesContactsEmailsBase();

    var WorkspacesContactsEmailsSearch = declare( [ WorkspacesContactsEmailsBase ],  {

      storeName:  'workspacesContactsEmailsSearch',
      collectionName: 'workspacesContactsEmails',

      publicURL: '/workspaces/:workspaceId/contactEmailsSearch/:id',
      hotExpose: true,

      handleGetQuery: true,      

      onlineSearchSchema: new HotSchema({
        isStarred: { type: 'boolean', trim: 20 },
        searchAll: { type: 'string', trim: 20 },
      }),

      queryConditions:{
        type: 'and',
        args: [
          {
            type: 'eq', args: [ 'contactId.isStarred', '#isStarred#' ],
          },

          {
            type: 'or',
            ifDefined: 'searchAll',
            args: [
              { type: 'startsWith', args: [ 'email', '#searchAll#' ] },
              { type: 'startsWith', args: [ 'contactId.firstName', '#searchAll#' ] },
              { type: 'startsWith', args: [ 'contactId.lastName', '#searchAll#' ] },
            ]
          }
        ]
      },
     
      defaultSort: { 'contactId.id': 1, __position: 1 },

      // This is here to add `previousContactId` to each record, so that
      // the rendering can be done properly
      afterEverything: function( request, method, done ){
 
        // Only affects getQuery
        if( method !== 'getQuery' ) return done( null );

        var queryDocs = request.data.preparedDocs;

        // Assign null to the previous element
        if( queryDocs.length ) queryDocs[ 0 ].previousContactId = null;

        // Assign previousContactId to the remaining elements
        for( var i = 1, l = queryDocs.length; i < l; i ++){
          queryDocs[ i ].previousContactId = queryDocs[ i - 1 ].contactId;
        }

        done( null );
      }


    });
    stores.workspacesContactsEmailsSearch = new WorkspacesContactsEmailsSearch();


    var WorkspacesContactsEmails = declare( [ WorkspacesContactsEmailsBase, UpdateFirstParentMixin ],  {

      firstParentStoreField: 'mainEmailId',

      storeName:  'workspacesContactsEmails',
      collectionName: 'workspacesContactsEmails',

      publicURL: '/workspaces/:workspaceId/contacts/:contactId/emails/:id',
      hotExpose: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,      

      position: true,

      onlineSearchSchema: new HotSchema({
        label    : { type: 'string', required: false, trim: 64 },
        email    : { type: 'string', required: false, notEmpty: false, trim: 70 },
      }),

      // Don't allow the same email address twice
      afterValidate: function( request, method, done ){
        var self = this;

        var body = request.body;

        if( method === 'get' || method === 'getQuery' ) return done( null );

        stores.workspacesContactsEmails.dbLayer.selectByHash( { conditions: { email: body.email, contactId: body.contactId } }, { children: true }, function( err, docs ){
          if( err ) return done( err );

          // Filter self out (only need to do it for PUT calls)
          if( method === 'put' ){
            docs = docs.filter( function(i) { return i.id.toString() != body.id.toString() } );
          }

          if( docs.length ){
            var errors = [];
            errors.push( { field: 'email', message: 'Email address already on file' } );
            done( new self.UnprocessableEntityError( { errors: errors } ) );
          } else {
            done( null );
          }
        });
      },

    });
    stores.workspacesContactsEmails = new WorkspacesContactsEmails();


    var WorkspacesContactsPhoneNumbersBase = declare( [ HotStore, MultiHomePermsMixin ],  {
  
      schema: new HotSchema({
        id         : { type: 'id', searchable: true },
        workspaceId: { type: 'id', searchable: true },
        contactId  : { type: 'id', searchable: true },

        label     : { type: 'string', searchable: true, required: false, trim: 64 },
        dialCode  : { type: 'string', searchable: true, required: true, notEmpty: true, trim: 4, min: 1, sharedValidator: 'countryDialCode' },
        number    : { type: 'string', searchable: true, required: true, notEmpty: true, trim: 20, min: 1, sharedValidator: 'phoneNumber', },
        fullNumber: { type: 'string', searchable: true, protected: true, trim: 24 }
      }),

      nested: [

        {
          type: 'lookup',
          localField: 'contactId',
          layer: 'workspacesContacts',
          layerField: 'id'
          //join: { 'id' : 'contactId' },
        },

      ],

      storeName:  'workspacesContactsPhoneNumbersBase',
      collectionName: 'workspacesContactsPhoneNumbers',

      idProperty: 'id',

      position: true,
      hotExpose: false,

      // Makes up fullNumber
      afterCheckPermissions: function( request, method, done ){

        // If it's a wrting method, update the protected field fullNumber
        if( method == 'post' || method == 'putNew' || method == 'putExisting' ){
          request.body.fullNumber = request.body.dialCode + request.body.number;
        }

        done( null );
      },

    });
    stores.workspacesContactsPhoneNumbersBase = new WorkspacesContactsPhoneNumbersBase();


   var WorkspacesContactsPhoneNumbersSearch = declare( [ WorkspacesContactsPhoneNumbersBase ],  {

      storeName:  'workspacesContactsPhoneNumbersSearch',
      collectionName: 'workspacesContactsPhoneNumbers',

      publicURL: '/workspaces/:workspaceId/contactPhoneNumbersSearch/:id',
      hotExpose: true,

      handleGetQuery: true,      

      onlineSearchSchema: new HotSchema({
        isStarred: { type: 'boolean', trim: 20 },
        searchAll: { type: 'string', trim: 20 },
      }),

      queryConditions:{
        type: 'and',
        args: [

          {
            type: 'eq', args: [ 'contactId.isStarred', '#isStarred#' ],
          },

          {
            type: 'or',
            ifDefined: 'searchAll',
            args: [
              { type: 'startsWith', args: [ 'number', '#searchAll#' ] },
              { type: 'startsWith', args: [ 'contactId.firstName', '#searchAll#' ] },
              { type: 'startsWith', args: [ 'contactId.lastName', '#searchAll#' ] },
            ]
          }
        ]
      },

      defaultSort: { 'contactId.id': 1, __position: 1 },


      // This is here to add `previousContactId` to each record, so that
      // the rendering can be done properly
      afterEverything: function( request, method, done ){
 
        // Only affects getQuery
        if( method !== 'getQuery' ) return done( null );

        var queryDocs = request.data.preparedDocs;

        // Assign null to the previous element
        if( queryDocs.length ) queryDocs[ 0 ].previousContactId = null;

        // Assign previousContactId to the remaining elements
        for( var i = 1, l = queryDocs.length; i < l; i ++){
          queryDocs[ i ].previousContactId = queryDocs[ i - 1 ].contactId;
        }

        done( null );
      }

    });
    stores.workspacesContactsPhoneNumbersSearch = new WorkspacesContactsPhoneNumbersSearch();

    var WorkspacesContactsPhoneNumbers = declare( [ WorkspacesContactsPhoneNumbersBase, UpdateFirstParentMixin ],  {

      firstParentStoreField: 'mainPhoneNumberId',

      storeName:  'workspacesContactsPhoneNumbers',
      collectionName: 'workspacesContactsPhoneNumbers',

      publicURL: '/workspaces/:workspaceId/contacts/:contactId/phoneNumbers/:id',
      hotExpose: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,      

      position: true,

      onlineSearchSchema: new HotSchema({
        label     : { type: 'string' },
        dialCode  : { type: 'string' },
        number    : { type: 'string' },
      }),

    });
    stores.workspacesContactsPhoneNumbers = new WorkspacesContactsPhoneNumbers();


    // Root-level store
    var PhoneNumbers = declare( [ HotStore ], {

      schema: new HotSchema({
        fullNumber: {
          type: 'string',
          required: true, 
          notEmpty: true,
          trim: 50,
          searchable: true
        },
        type: { 
          type: 'string',
          required: true,
          notEmpty: true,
          trim: 9,
          searchable: true,
          validator: function( o, v, fieldName ){ 
            if( v !== 'private' && v !== 'shared' && v !== 'available') return "Type must be 'private', 'available' or 'shared'";
          }
        },
        provider: { 
          type: 'string',
          required: true,
          notEmpty: true,
          trim: 10,
          searchable: true,
          validator: function( o, v, fieldName ){
            if( v !== 'twilio' && v !== 'plivo' ) return "Provider must be 'plivo' or 'twilio'";
          }
        },
        workspaceId: {
          type: 'id',
          required: false,
          notEmpty: true,
          searchable: true,
          validator: function( o, v, fieldName ){
            if( o.type == 'private' && ! v ) return "You need to specify the workspace ID for private phone numbers";
          } 
        },
      }),

      onlineSearchSchema: new HotSchema( {
        fullNumber       : { type: 'string' },
        type             : { type: 'string' },
        provider         : { type: 'string' },
        workspaceId      : { type: 'id' },
        workspaceIdFilter: { type: 'id' },
      }),

      queryConditions: {
        type: 'and',
        args: [
          { type: 'contains', args: [ 'fullNumber', '#fullNumber#'] },
          { type: 'eq', args: [ 'type', '#type#'] },
          { type: 'eq', args: [ 'provider', '#provider#'] },
          { type: 'eq', args: [ 'workspaceId', '#workspaceId#'] },

          {
            type: 'or',
            args: [
              { type: 'eq', args: [ 'workspaceId', '#workspaceIdFilter#'] },
              { type: 'eq', args: [ 'type', 'shared' ] },
            ]
          }
        ]
      },

      storeName:  'phoneNumbers',
      publicURL: '/phoneNumbers/:id',
      hotExpose: true,
  
      alwaysRefreshOnChange: true,

      position: true,

      hotGlobalBroadcast: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,  
    });
    stores.phoneNumbers = new PhoneNumbers();



    // Plivo config store
    var PlivoConfig = declare( [ HotStore ], {

      schema: new HotSchema({
        account         : { type: 'string', notEmpty: false, trim: 50, searchable: true },
        token           : { type: 'string', notEmpty: false, trim: 50, searchable: true },        
      }),

      onlineSearchSchema: new HotSchema({
      }),

      storeName:  'plivoConfig',
      publicURL: '/config/plivoConfig/:globalId',
      hotExpose: true,
      configStore: { globalId: true },

      position: true,

      hotGlobalBroadcast: true,

      handlePut: true,
      handlePost: true,
      handleGet: true,
      handleGetQuery: true,
      
    });
    stores.plivoConfig = new PlivoConfig();

    var WorkspacesEmailConfig = declare( [ HotStore, MultiHomePermsMixin ], {

      schema: new HotSchema({
        systemName  : { type: 'string', required: false, default: "Email system", notEmpty: true, trim: 70},
        systemEmail : { type: 'string', required: false, default: "youremail@example.com", sharedValidator: 'email', notEmpty: true, trim: 255},
        smtpServer      : { type: 'string', required: false,  trim: 256, },
        smtpPort        : { type: 'number', required: true, default: '586' },        
        smtpLogin       : { type: 'string', required: false,  trim: 256, },
        smtpPassword    : { type: 'string', required: false,  trim: 256, },

        imapServer      : { type: 'string', required: false,  trim: 256, },
        imapPort        : { type: 'number', required: true, default: '993' },        
        imapLogin       : { type: 'string', required: false,  trim: 256, },
        imapPassword    : { type: 'string', required: false,  trim: 256, },
        imapPollInterval: { type: 'number', required: true, default: '300', min: 60, max: 600 },

      }),

      onlineSearchSchema: new HotSchema({
      }),

      storeName:  'workspacesEmailConfig',

      publicURL: '/config/workspacesEmailConfig/:workspaceId',
      hotExpose: true,
      configStore: { workspaceId: true },

      handlePut: true,
      handleGet: true,

      prepareBeforeSend: function( request, method, doc, cb ){
        var doc = this._co( doc );

        doc.id = doc.workspaceId;
        cb( null, doc );
      },

    });
    stores.workspacesEmailConfig = new WorkspacesEmailConfig();

    var WorkspacesSmsConfig = declare( [ HotStore, MultiHomePermsMixin ], {

      schema: new HotSchema({
        phoneNumberId : { searchable: true, type: 'id', required: false },
      }),

      onlineSearchSchema: new HotSchema({
      }),

      nested: [
        {
          type: 'lookup',
          localField: 'phoneNumberId',
          layer: 'phoneNumbers',
          layerField: 'id'
          //join: { 'id' : 'phoneNumberId' },
        },
      ],

      storeName:  'workspacesSmsConfig',

      publicURL: '/config/workspacesSmsConfig/:workspaceId',
      hotExpose: true,
      configStore: { workspaceId: true },

      handlePut: true,
      handleGet: true,
    });
    stores.workspacesSmsConfig = new WorkspacesSmsConfig();


    // YOU ARE HERE
    // PSEUDO-STORE, allows creation of contacts with attached phone number
    // or email address in one go. It also tries to complete the basic information
    // (name, lastname) if email address.
    var ContactsCreator = declare( JsonRestStores, JsonRestStores.HTTPMixin, {
  
      // COMMON
      schema: new SimpleSchema({
        type    :      { type: 'string'},
        from    :      { type: 'blob' }, // This is 'blob' as SimpleSchema has numbers for IDs by default
      }),
    
      storeName:  'contactsCreator',
  
      publicURL: '/workspaces/:workspaceId/contactsCreator/:id',
      hotExpose: true,
      type: 'uncached',

      handlePost: true,

      
      implementFetchOne: function( request, done ){
        done( null );
      },
  
    });
    stores.contactsCreator = new ContactsCreator();


    // Make up stores derived from hotCoreTransport
    hotplate.hotEvents.emitCollectModule( 'stores', 'hotCoreTransport', function( err, results){
      if( err ) return done( err );
    
      var messages = results.onlyResults()[ 0 ]['messages'];  

      var OnlineMessages = declare( [ messages.constructor, s.HotStoreMixin, MultiHomePermsMixin  ], {
        storeName: 'onlineMessages',
        collectionName: 'messages',

        handleGet: true,
        hotExpose: true,
        publicURL: '/messages/:id',
      });
      stores.onlineMessages = new OnlineMessages();

      done( null, stores );

    })

  });

}));


// Simply activate path to client files
hotplate.hotEvents.onCollect( 'clientPath', 'bd', function( done ){
  done( null, path.join(__dirname, '../client') );
} )

// Define which paths within clientPath will need to be rendered, and with which options
hotplate.hotEvents.onCollect( 'clientPathRender', 'bd', function( done ){
  done( null, [
    {
      'templates/BookingDojo.jade': { name: 'Tony' },
      'templates/AnotherBookingDojo.jade': {},
    }
  ] );
});



hotplate.hotEvents.onCollect( 'dojoModulesPerPage', 'bd', function( req, pageName, done ){

  switch( pageName ){

    case 'hotClientDojo/container':
      done( null, [ 'bdMain' ] );
    break;

    default:
      done( null, [ ] );
    break;
  }

});


hotplate.hotEvents.onCollect( 'pageElements', 'bd', function( done ){
    done( null, { titleWords: [ "Booking Dojo" ] } );
})

hotplate.hotEvents.onCollect( 'pageElementsPerPage', 'bd', function( req, pageName, done ){

  switch(pageName){

    case 'hotClientDojo/container':

      hotCoreStoreRegistry.getAllStores( function( err, storeRegistry ){
        if( err ) return done( err );

        storeRegistry.workspacesContacts.dbLayer.selectByHash( { conditions: { userId: req.session.userId } }, function( err, record ){
          if( err ) return done( err );
          if( record === null ) return new Error("Could not find contact associated to user");
        
          // Sending the page out, with CSS, title _AND_ with the userContactId as 
          // set as the contact 
          done( null, {
            csses: ['bdMain.css' ],
            titleWords: [ "Application" ],
            vars: [ { name: 'userContact',  value: record[ 0 ] } ]
          });
        })
      });
    break;

   default:
      done( null, {} );
    break;
  }
});

hotplate.hotEvents.onCollect( 'sharedFunctions', 'bd', hotplate.cachable( function( done ) {

  var result = {};

  result.phoneNumberValidator = function( number ){
    if( number === false ) return "Phone number invalid, only numbers and spaces allowed";
    return number.match( /^[0-9 ]+$/ );
  };

  result.renderContactName = function( c ){
    return ( c.firstName ? c.firstName + ' ' : '' ) +
           ( c.lastName ? c.lastName + ' ' : '' );
  };


  done( null, result );
}));
