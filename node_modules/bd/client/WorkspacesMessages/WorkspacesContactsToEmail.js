
define([
  "dojo/_base/declare"

, "dojo/on"
, "dojo/dom-construct"

, "dijit/layout/TabContainer"
, "dijit/layout/ContentPane"
, "dijit/form/Button"

, "hotplate/hotDojoWidgets/widgets"
, "hotplate/hotDojoWidgets/Dummy"

, "hotplate/bd/WorkspacesContactsPicker"

], function(
  declare

, on
, domConstruct

, TabContainer
, ContentPane
, Button

, widgets
, Dummy
, WorkspacesContactsPicker

){

  return declare( [ widgets.DestroyableTemplatedContainer ], {

    _alreadyAddedHash: {},
    initialTo: null,

    templateString: '' +
      '<div class="workspaces-contacts-cc-email-container">\n' +
      '  <div class="workspaces-contacts-cc-email">\n' +
      '    <span class="to">To:</span>\n' +
      '    <span class="contacts-list" data-dojo-attach-point="contactsListNode"></span>\n' +
      '    <span class="plus" data-dojo-attach-point="buttonWidget" data-dojo-type="dijit/form/Button">+</span>\n' +      
      '  </div>\n' +
      '</div>\n' +
      '',

    postMixInProperties: function(){

      // Make up this.initialTo with the two objects
      if( this.defaultTo && this.defaultTo._children.mainEmailId ){
        this.initialTo = { contactObject: this.defaultTo, emailObject: this.defaultTo._children.mainEmailId };
      }

    },

    constructor: function(){
      this._alreadyAddedHash = {};
    },

    resetTo: function(){
      var self = this;

      // Delete alla elements, and add self once again
      domConstruct.empty( self.contactsListNode );
      self._alreadyAddedHash = {};

      if( self.initialTo ){
        self._addElement( self.initialTo.contactObject, self.initialTo.emailObject );
      }

    },

    _addElement: function( contactObject, emailObject ){

      var self = this;

      // Won't add the same element twice
      if( self._alreadyAddedHash[ emailObject.id ] ) return;
      self._alreadyAddedHash[ emailObject.id ] = 'single';

      var formattedName = contactObject.firstName + ' &lt;' + emailObject.email + '&gt;'

      var element = domConstruct.toDom( '<div class="contact" tabIndex="0">' + formattedName + '<div class="contact-x"></div></div>');
      element.itemType = 'single';
      element.itemId = emailObject.id;
      domConstruct.place( element, self.contactsListNode, 'last' );
    },

    postCreate: function(){
      var self = this;

      self.own( 

        on( self, 'keypress' , function( e ){

          //debugger;
          console.log( e.charCode );
        
          if( e.charCode === 127 ){
            e.preventDefault();

            var src = e.srcElement;

            // Focus on the previous or next sibling
            if( src.previousSibling && src.previousSibling.className === 'contact' ) src.previousSibling.focus();
            else if( src.nextSibling && src.nextSibling.className === 'contact' ) src.nextSibling.focus();

            // Delete from DOM _and_ from the _alreadyAdded hash
            delete self._alreadyAddedHash[ src.itemId ];
            domConstruct.destroy( src );


            return false;
          }
          
        }),

        on( self, 'click', function( e ){

          var src = e.srcElement;
          if( src.className === 'contact-x' ){

            // Delete from DOM _and_ from the _alreadyAdded hash
            delete self._alreadyAddedHash[ src.parentElement.itemId ];
            domConstruct.destroy( src.parentElement );
          }
        }),


        on( self.buttonWidget, 'click', function( e ){
          var workspacesContactsPicker = new WorkspacesContactsPicker( { type: 'Emails' } );// PhoneNumbers
          workspacesContactsPicker.startup();
          workspacesContactsPicker.show();

          workspacesContactsPicker.on( 'selection-done', function( e ){

            self._addElement( e.row.data._children.contactId, e.row.data );

          })

        })
      );

            // If self.initialTo is set, then add that first element as the initial email address
      if( self.initialTo ){
        self._addElement( self.initialTo.contactObject, self.initialTo.emailObject );
      }

    },


  });

});
