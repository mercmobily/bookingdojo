define([
  "dojo/_base/declare"




, "hotplate/bd/WorkspacesMessages/WorkspacesContactsToSms"
, "hotplate/hotDojoWidgets/EditingWidget"
, "hotplate/hotDojoWidgets/ValidationTextArea"


, "hotplate/hotDojoWidgets/BusyButton"
, "hotplate/hotDojoStoreConfig/ConfigVars"
, "hotplate/hotDojoGlobals/globals"
, "hotplate/hotDojoWidgets/util"
, "hotplate/hotDojoStores/stores"
], function(
  declare

, WorkspacesContactsToSms
, EditingWidget
, ValidationTextarea

, BusyButton
, ConfigVars
, globals
, util
, stores

){
  return declare([ EditingWidget ], {

    maxLength: 384,
    templateString: '' +
      '<div>\n' +
      '  <form data-dojo-type="dijit/form/Form" data-dojo-attach-point="formWidget" method="POST">\n' +

      '    <div id="${id}_from" name="from" >\n' +
      '      <span class="from">From: </span>\n' +
      '      <span class="from-name-node" data-dojo-attach-point="fromNameNode"></span>\n' +
      '    </div>\n' +

      '    <div id="${id}_to" name="to" data-dojo-attach-point="to" data-dojo-type="hotplate/bd/WorkspacesMessages/WorkspacesContactsToSms" data-dojo-props="defaultTo: this.contactObject"></div>\n' +

      '    <div data-dojo-attach-point="counterNode"></div>\n' +

      '    <input id="${id}_body" style="min-height:4em;max-height:4em;display:block" name="body" data-dojo-type="hotplate/hotDojoWidgets/ValidationTextArea" data-dojo-props="required:true, validator: this.messageValidator" data-dojo-attach-point="bodyWidget" />\n' +

      '    <input class="form-submit" type="submit" data-dojo-attach-point="buttonWidget" data-dojo-type="hotplate/hotDojoWidgets/BusyButton" label="Send" />' +
      '  </form>\n'+
      '</div>\n'+
      '',
    alertBarDomPlacement: 'first',
    resetOnSuccess: true, 

    messageValidator: function( value, constraints ){
      var self = this;

      //console.log('Validating:', value, self.maxLength, self.maxLength - value.length  )
      return self.maxLengthValidation - value.length > 0;
    },

    manipulateValuesBeforeSubmit: function( values ){
      values.type = 'sms';
    },

    savedMessage: 'SMS queued!',

    _updateCounter: function( ){
      var self = this;
      var l = self.maxLength - self.bodyWidget.get('value').length;
      self.counterNode.innerHTML = l;
      self.counterNode.className = l >= 0 ? 'black' : 'red';
    },

    postCreate: function(){
      this.inherited(arguments);

      var self = this;

      self._updateCounter();

      self.bodyWidget.on('keyup', function(e){
        self._updateCounter();
      });

      // Editor doesn't implement reset, have to reset it by hand... ugh!
      this.on( 'successfulsubmit', function(){
        self._updateCounter();

        self.to.resetTo();
      });

      // This will make maxLength available to the textbox's validator
      self.bodyWidget.maxLengthValidation = self.maxLength;

      // Have the first name...
      var me = ConfigVars.workspacesUsersInfo._children.workspacesContacts[0];
      self.fromNameNode.innerHTML = util.escapeHTML( me.firstName );
      // ...and make sure to update it if it changes
      var workspacesContactsStore = stores('workspacesContacts', { workspaceId: globals.workspaceId } ) ;
      workspacesContactsStore.on( 'update', function( event ){
        if( event.target.id == me.id ){
          self.fromNameNode.innerHTML = util.escapeHTML( event.target.firstName );
        }
      });

    },

    manipulateValuesBeforeSubmit: function( values ){

      var self = this;

      values.type = 'sms';

      // Create the list of email IDs to be submitted -- comma separated
      values.to = '';
      var a = [];
      var keys = Object.keys( self.to._alreadyAddedHash );
      for( var i = 0, l = keys.length; i < l; i ++ ){
        a.push( keys[ i ] );
      }
      values.to = a.join( ',' );
    },

   savedMessage: 'SMS queued!',

  });
});