/*
INPUT: 
  * workspaceId
  * [contactId]
DESCRIPTION
The list of messages for a specified workspace (`workspacesMessages`). If contactId is set, the messages will be filtered by contactId. The store server-side `workspacesMessages` will make sure that messages from _and_ to that specific contactId are displayed when filtering by contactId.
Double-clicking on a message will result in opening up the message and see its details.
*/

define([
  "dojo/_base/declare"

, "dijit/form/ValidationTextBox"

, "put-selector/put"

, "hotplate/hotClientDojo/dgridWidgets/commonMixins"
, "hotplate/hotClientDojo/dgridWidgets/EditableList"
, "hotplate/hotClientDojo/widgets/BusyButton"
, "hotplate/hotClientDojo/globals/globals"
, "hotplate/hotClientDojo/widgets/TempDialog"
, "hotplate/hotClientDojo/widgets/widgets"

, "hotplate/bd/WorkspacesMessages/WorkspacesMessagesNew"
, "hotplate/bd/WorkspacesMessages/WorkspacesMessagesView"
, "hotplate/bd/formatters"


], function(
  declare

, ValidationTextBox

, put

, commonMixins
, EditableList
, BusyButton
, globals
, TempDialog
, widgets

, WorkspacesMessagesNew
, WorkspacesMessagesView
, formatters

){
  return declare( [ EditableList ], {

    // Sets initialFilter to the right contactId
    postMixInProperties: function(){
      this.inherited(arguments);

      this.initialFilter = this.contactId  ? { contactId: this.contactId } : {};
      this.storeParameters = { workspaceId: this.workspaceId };
    },

    xConstructorParameters: function( type, recordId ){
      return {
        workspaceId: this.workspaceId,
        contactId: this.contactId
      };
    },

    ownClass: 'workspaces-contacts-messages',

    ListConstructor: declare( [ commonMixins.FullOnDemandGridNoDnd ], {

      columns: {

        type: {
           label: "Type",
           sortable: false,
           renderCell: function( object, value, node, options ){
            return put('span.type', object._children.messageId.type );
          } 
        },

        from: {
          label: "From",
          sortable: false,
          renderCell: function( object, value, node, options ){
            var incoming = object._children.messageId ? object._children.messageId.incoming : '';
            var message = object._children.messageId ? object._children.messageId : '';
            var fromContact = object._children.messageId ? object._children.fromContactId : '';
            var from = message.from;

            if( incoming ) {

              if( object.fromContactId ){
                return put('span.from', formatters.contactName( fromContact ) + ' via ' + message.from ); 
              } else {
                return put('span.from', 'Unknown via ' + message.from );  
              }

            } else {
              return put('span.from', formatters.contactName( fromContact ) );
            }

          }
        },

        to: {
          label: "To",
          sortable: false,
          renderCell: function( object, value, node, options ){ 
            var tos = object._children.workspacesMessagesTo;
            //return put('span.to', tos.map( function( o ) { return o.contactId.substr(-2) } ).join(',') );
            return put('span.to', object.toAsString );

          }
        },

        subjectBody: {
          label: 'Contents',
          sortable: false,
          renderCell: function( object, value, node, options ){ 

            var message = object._children.messageId;
            var subject, body, textPreview;

            // If it's an SMS, it's guaranteed to just have bodyText. Don't
            // even bother trying to work with HTML
            if( message.type === 'sms'){
              return put('span.preview', message.bodyText );
            }

            // At this point, it needs to create the message which will me either "subject - body"
            // (if there is a subject) or "body" (if there is no subject). To do that, work out
            // `subject` and `body` first

            // Work out subject 
            if( message.subject ){
              subject = message.subject;
            }

            // Work out body. This is a preview, so I just want the body in text format.
            // However, I might or might NOT have bodyText (depends on the email client).
            // So, if `bodyText` is there, use it
            if( message.bodyText ){
              body = message.bodyText;

            // Otherwise, if bodyText isn't there, work something out from bodyHtml (stripping
            // ALL tags from bodyHtmlSane)
            } else if( message.bodyHtml ){

              // Make up the stripped version of the SAFE HTML
              var tmp = document.createElement("DIV");
              tmp.innerHTML = message.bodyHtmlSane || '';
              body = tmp.textContent || tmp.innerText || "";

            // If there is no text now HTML body (Apple clients apparently do that with messages
            // with no body and just attachments), then body is empty.
            } else {
              body = '';
            }

            // Clean up the body
            body = body.replace(/On +(Mon|Tue|Wed|Thu|Fri|Sat|Sun)[\s\S]*wrote: */gim,'').substr( 0, 120);
            body = body.replace(/>/gim, '' );


            // It's best to put *something* in there
            if( body === '' ) body = "(Empty)";

            //textPreview = textPreview.replace(/On [a-zA-Z]+\, [0-9]+ +[a-zA-Z]+ 20[0-9][0-9].*$/m, '')
            textPreview = ( subject ? subject + ' â€” ' : '' ) + body;
            return put('span.preview', textPreview );
          }
        },

        date: {
          label: 'Date',
          sortable: false,
          renderCell: function( object, value, node, options){  
            return put('span.date', formatters.dateAlaGoogle( new Date( object.added ) ) );

          }
        },
      },
    }),
    
    ExtraWidgetConstructor: declare( [ widgets.DestroyableTemplatedContainer ], {
      templateString: '' +
        '<div>\n' +
        '  <div data-dojo-attach-point="newMessageButtonWidget" class="new-message" data-dojo-type="hotplate/hotClientDojo/widgets/BusyButton" label="New message" /></div>\n' +
        '</div>\n'+
        '',
    }),
    extraWidgetPosition: 'top',

    storeName: 'workspacesMessages',
    editingWidgetPlacement: 'inline',
    multipleEditingAllowed: false,
    closeDialogAfterSubmit: true,

    buttonsPosition: 'after', // or "top" or "bottom"

    AddingWidgetConstructor: WorkspacesMessagesNew,

    postCreate: function(){
      this.inherited(arguments);

      var self = this;

      self.own(

        self.extraWidget.newMessageButtonWidget.on( 'click', function( e ){
          self.addingWidgetConstructorInDialog( 'Send message' );
        }),

        self.listWidget.on( 'dblclick' , function( e ){
          var row = self.row( e );

          var tempDialog = new TempDialog( {
            title: "View " + row.data._children.messageId.type,
            closable: true
          } );
          var view = new WorkspacesMessagesView( { workspaceMessage: row.data } );

          tempDialog.addChild( view );
          tempDialog.startup();

        })
       );
    },
  });
});



