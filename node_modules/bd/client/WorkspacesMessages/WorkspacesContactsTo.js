
define([
  "dojo/_base/declare"

, "dojo/on"
, "dojo/dom-construct"

, "dijit/layout/TabContainer"
, "dijit/layout/ContentPane"
, "dijit/form/Button"

, "hotplate/hotClientDojo/widgets/widgets"
, "hotplate/hotClientDojo/widgets/ViewingWidget"
, "hotplate/hotClientDojo/widgets/Dummy"

, "hotplate/bd/WorkspacesContactsPicker"

, "hotplate/bd/WorkspacesMessages/WorkspacesMessagesPhoneNumbersSelect"
, "hotplate/bd/WorkspacesMessages/WorkspacesMessagesEmailsSelect"

], function(
  declare

, on
, domConstruct

, TabContainer
, ContentPane
, Button

, widgets
, ViewingWidget
, Dummy
, WorkspacesContactsPicker

, WorkspacesMessagesPhoneNumbersSelect
, WorkspacesMessagesEmailsSelect

){

  return declare( [ ViewingWidget ], {

    _alreadyAddedHash: {},

    templateString: '' +
      '  <div class="workspaces-contacts-to">\n' +

      '    <div class="main-to-container" data-dojo-attach-point="mainToContainerNode">\n' +
      '      <span class="main-to-screen" data-dojo-attach-point="mainToScreenNode"></span>\n' +
      '      <span class="main-to" data-dojo-attach-point="mainToNode"></span>\n' +
      '    </div>\n' +

      '    <div class="to-container" data-dojo-attach-point="toContainerNode">\n' +
      '      <span class="to-screen" data-dojo-attach-point="toOrCcNode"></span>\n' +
      '      <span class="to" data-dojo-attach-point="toNode"></span>\n' +
      '    </div>\n' +

      '    <span class="plus" data-dojo-attach-point="buttonWidget" data-dojo-type="dijit/form/Button">+</span>\n' +      
      '  </div>\n' +
      '',

    postMixInProperties: function(){
      this.inherited(arguments);

      if( this.contactId ){
        this.info = {

          workspacesContacts: {
            storeParameters: { workspaceId: this.workspaceId },
            id: this.contactId,
          }
        }
      }
    },

    renderInfo: function(){
      if( this.contactId ){
        this.mainToScreenNode.innerHTML = "To: " + this.info.workspacesContacts.data.firstName;
      } else {
        this.mainToContainerNode.style="display: none";        
      }
    },

    constructor: function(){
      this._alreadyAddedHash = {};
    },

    postCreate: function(){
      var self = this;

      this.inherited( arguments );

      // The form will change slightly depending on defaultTo
      // 
      if( self.contactId ){
        self.toOrCcNode.innerHTML = "Cc:";

        // Uses the right select widget depending on the recipient type
        switch( self.recipientType ){
          case 'PhoneNumbers':
            self.mainTo = new WorkspacesMessagesPhoneNumbersSelect( { workspaceId: self.workspaceId, contactId: self.contactId }, self.mainToNode );
          break;
          case 'Emails':
            self.mainTo = new WorkspacesMessagesEmailsSelect( { workspaceId: self.workspaceId, contactId: self.contactId }, self.mainToNode );
          break;
        }

      } else {
        self.toOrCcNode.innerHTML = "To: ";
      }

      self.own( 

        on( self, 'keypress' , function( e ){
        
          if( e.charCode === 127 ){
            e.preventDefault();

            var src = e.srcElement;

            // Focus on the previous or next sibling
            if( src.previousSibling && src.previousSibling.className === 'contact' ) src.previousSibling.focus();
            else if( src.nextSibling && src.nextSibling.className === 'contact' ) src.nextSibling.focus();

            // Delete from DOM _and_ from the _alreadyAdded hash
            delete self._alreadyAddedHash[ src.itemId ];
            domConstruct.destroy( src );


            return false;
          }
          
        }),

        on( self, 'click', function( e ){

          var src = e.srcElement;
          if( src.className === 'contact-x' ){

            // Delete from DOM _and_ from the _alreadyAdded hash
            delete self._alreadyAddedHash[ src.parentElement.itemId ];
            domConstruct.destroy( src.parentElement );
          }
        }),


        on( self.buttonWidget, 'click', function( e ){
          var workspacesContactsPicker = new WorkspacesContactsPicker( { type: self.recipientType, workspaceId: self.workspaceId } );
          workspacesContactsPicker.startup();
          workspacesContactsPicker.show();

          workspacesContactsPicker.on( 'selection-done', function( e ){

            self._addElement( e.row.data._children.contactId, e.row.data );

          })

        })
      );

    },


    resetTo: function(){
      var self = this;

      // Delete alla elements, and add self once again
      domConstruct.empty( self.toNode );
      self._alreadyAddedHash = {};

    },

    _addElement: function( contactObject, recipientObject ){

      var self = this;
      var formattedRecipient;

      // The "contents" will depend on the type of recipient; eventually, it would be
      // better if the server returned a "rendered" field to avoid this.
      if( self.recipientType === 'PhoneNumbers') {
        formattedRecipient = recipientObject.number;
      } else {
        formattedRecipient = recipientObject.email;        
      }

      // Won't add the same element twice
      if( self._alreadyAddedHash[ recipientObject.id ] ) return;
      if( self.mainTo && self.mainTo.get( 'value' ) === recipientObject.id ) return;

      self._alreadyAddedHash[ recipientObject.id ] = 'single';

      // Make up the formatted name
      var formattedName = contactObject.firstName + ' ' + contactObject.lastName + ' &lt;' + formattedRecipient + '&gt;'

      var element = domConstruct.toDom( '<div class="contact" tabIndex="0">' + formattedName + '<div class="contact-x"></div></div>');
      element.itemType = 'single';
      element.itemId = recipientObject.id;
      domConstruct.place( element, self.toNode, 'last' );
    },

    _setValueAttr: function( v ){
      if( this.mainTo ) this.mainTo.set( 'value', v );
    },

    _getValueAttr: function(){

      var self = this;

      // Create the list of email IDs to be submitted -- comma separated
      var a = [];
      var keys = Object.keys( self._alreadyAddedHash );
      for( var i = 0, l = keys.length; i < l; i ++ ){
        a.push( keys[ i ] );
      }
      if( self.mainTo ) a.push( self.mainTo.get( 'value' ));
      return a.join( ',' );

    },

  });

});
