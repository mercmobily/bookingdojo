define([
   "dojo/_base/declare",
   "dojo/when",
   "dojo/store/Observable",
   "dojo/topic",
   "dojo/on",
   "dojo/_base/lang",
   "dojo/dom-construct",
   "dojo/dom-style",
   "dojo/dom-attr",

   "dijit/_WidgetBase",
   "dijit/_TemplatedMixin",
   "dijit/_WidgetsInTemplateMixin",
   "dijit/Destroyable",
   "dijit/Dialog",
   "dijit/_OnDijitClickMixin",

   "dijit/layout/BorderContainer",
   "dijit/layout/StackContainer",
   "dijit/layout/TabContainer",
   "dijit/layout/ContentPane",
   'dijit/_Container',
   'dijit/layout/_ContentPaneResizeMixin',

   'dgrid/List',
   'dgrid/OnDemandList',
   "dgrid/Selection",
   "dgrid/Keyboard",
   'put-selector/put',

   "hotplate/hotDojoAuth/LogoutButton",
   "hotplate/hotDojoWidgetHooks/_TemplatedHooksMixin",
   "hotplate/hotDojoStores/stores",
   "hotplate/hotDojoStores/AppStoreNotify",
   "hotplate/hotDojoWidgets/_OverlayMixin",
   "hotplate/hotDojoWidgets/EditingWidget",
   "hotplate/hotDojoCometMessages/messages",

   "hotplate/bd/globals",
   "hotplate/bd/AccessConfig",
   "hotplate/bd/AdminConfig",
   "hotplate/bd/UserConfig",

   "hotplate/bd/AppConfigVars",

   // "app/widgets/SearchPage",

   ], function(
     declare
     , when
     , Observable
     , topic
     , on
     , lang
     , domConstruct
     , domStyle
     , domAttr

     , _WidgetBase
     , _TemplatedMixin
     , _WidgetsInTemplateMixin
     , Destroyable
     , Dialog
     , _OnDijitClickMixin

     , BorderContainer
     , StackContainer
     , TabContainer
     , ContentPane
     , _Container
     , _ContentPaneResizeMixin

     , List
     , OnDemandList
     , Selection
     , Keyboard
     , put

     , LogoutButton
     , _TemplatedHooksMixin
     , stores
     , dummy
     , _OverlayMixin
     , EditingWidget
     , messages

     , globals
     , AccessConfig
     , AdminConfig
     , UserConfig

     , AppConfigVars

 ){



    var EditableList = declare( _WidgetBase, {

      _editing: {},

      constructor: function( params ){
        this.store = stores( params.storeName, params.storeFields );
        this.editing = {};
      },

      store: null,
      storeName: '',
      storeFields: {},

      renderRow: function( item ){
        put( 'div', item )
      },

      row: function( p ){
        return this.listWidget.row( p );
      },

      listWidget: null,

      EditingConstructor: null,
      editingWidget: null,
      editingWidgetPosition: 'popup', // 'popup', 'inplace',

      AddingConstructor: null,
      addingWidget: null,
      addingWidgetPosition: 'nowhere', // 'above', 'before', 'after',


      buildRendering: function(){

        this.listWidget = new this.ListConstructor( { store: this.store } );

        this.domNode = put( 'div' );

        // if( this.addingWidgetPosition === 'before' && this.addingWidget ) put( this.domNode, this.addingWidget );
        put( this.domNode, this.listWidget.domNode );
        // if( this.addingWidgetPosition === 'after' && this.addingWidget ) put( this.domNode, this.addingWidget );

        this.inherited(arguments); 

      },


      // Allows editing of an item in a dialog box
      //
      _editInDialog: function( item ){
        var self = this;
        var editingWidget;

        // Create an editing widget using the passed constructor. However,
        // it will set storeName, storeFields and recordId
        editingWidget = new self.EditingConstructor({
          storeName: self.storeName,
          storeFields: self.storeFields,
          recordId: item.id,
        });

        // Make up the dialog with editing widget, show it
        self.dialog = new Dialog({
          title: "Edit",

          // The widget was created programmatically: destroy on hiding
          hide: function(){

            // Dialog.hide() returns a promise, which resolves when
            // the hiding animation is over. 
            // First of all, get this promise...
            var p = this.inherited('hide', arguments ); // Need the name, this will be lang.mixin, not declare.safeMixin

            // Attach a new callback triggered when the animation is over:
            // the callback will destroy the widget
            p.then( lang.hitch(this, function(){
              this.destroyRecursive();
            }));

            // Return the promise, in case other calls want to
            // attach more callbacks to it
            return p;
          },

        });

        self.dialog.addChild( editingWidget );
        self.dialog.startup();
        self.dialog.show();

        editingWidget.on( 'successfulsubmit', function(){
          self.dialog.hide();
        });

      },

      // Allows editing of an item inline
      //
      _editInline: function( item ){
        var self = this;
        var editingWidget;
        var oldDomContents = item.element;

        if( self._editing[ item.id ] == true ) return;
        self._editing[ item.id ] = true;

        console.log( self._editing );


        // Create an editing widget using the passed constructor. However,
        // it will set storeName, storeFields and recordId
        editingWidget = new self.EditingConstructor({
          storeName: self.storeName,
          storeFields: self.storeFields,
          recordId: item.id,
        });

        // Give the row the class .dgrid-cell-editing
        put( item.element, ".dgrid-cell-editing");

        // Add the editing widget to the row domNode. It will have
        // absolute positioning, which means it will overlap
        // the actual row
        put( item.element, editingWidget.domNode );
        domStyle.set( item.element, 'position', 'relative' );
        domStyle.set( editingWidget.domNode, 'position', 'absolute' );
        domStyle.set( editingWidget.domNode, 'top', 0 );
        domStyle.set( editingWidget.domNode, 'z-index', 10 );

        // FIXME: This should be in the CSS
        // ALSO FIX CSS in terms of forms: have two classes, one for "one-liners" and one for complex forms
        domStyle.set( editingWidget.domNode, 'background-color', 'grey' );
        domStyle.set( editingWidget.domNode, 'width', '100%' );

        // Startup and show the widget
        editingWidget.startup();
        editingWidget._onShow();

        // Escape and successful submit will close this form (properly)
        // by taking the class out, delete the self.editing entry,
        // and destroying the widget
        editingWidget.formWidget.on( 'keypress' , function( e ){
          if( e.keyCode == 27 ) closeThis(); 
        }),
        editingWidget.on( 'successfulsubmit', function(){
          closeThis();
        });
        function closeThis(){
          put( item.element, "!dgrid-cell-editing");
          delete self._editing[ item.id ];
          editingWidget.destroyRecursive();
        }

      },

      postCreate: function(){

        this.inherited(arguments); 
        var self = this;       

        // Double-click will trigger editing 
        self.listWidget.on('.dgrid-row:dblclick, .dgrid:enter', function(e){
          var item = self.row( e );
          II = item;
          self._editInDialog( item );
          // self._editInline( item );
          
              
        })

      },

      startup: function(){
        this.inherited(arguments); 
        this.listWidget.startup();
      },


    });

  

    // Create the "login" pane, based on a normal ContentPane
     // var Dashboard = declare('hotplate/bd/Dashboard',  [_WidgetBase, _Container, _ContentPaneResizeMixin, Destroyable, _OverlayMixin, _TemplatedMixin, _WidgetsInTemplateMixin ], {
     var Dashboard = declare('hotplate/bd/Dashboard',  [ ContentPane, Destroyable, _OverlayMixin, _TemplatedMixin, _WidgetsInTemplateMixin ], {

      widgetsInTemplate: true,

      templateString: jade.compile('' +
        'div\n' +
        '  p Ahah\n' +
        '  p Ahah\n' +
        '  p Ahah\n' +
        '  p Ahah\n' +
        '  p Ahah\n' +
        '  div( data-dojo-attach-point="listNode")\n'+
        '  div( data-dojo-attach-point="editableListNode")\n'+
        '')(),


        postCreate:function(){
          var that = this, q;

          T = this;

          this.inherited(arguments);

          var escapeHTML = function( str ) {
            var div  = document.createElement( 'div' );
            var text = document.createTextNode( str );
            div.appendChild( text );
            return div.innerHTML;
          };

          


        },

        startup: function(){
          this.inherited(arguments);


          //var SuperList = declare( [List, Selection, Keyboard ], {
          //  renderRow: function( item ){
          //    return put('div', "HERE:" + item );
          //  }
          //} );
          // attach to a DOM element indicated by its ID
          // this.list = L = new SuperList( { className:'select-list' }, this.listNode );
          // render some data
          //this.list.renderArray(['one', 'two', 'three', 'one', 'two', 'three', 'one', 'two', 'three', 'one', 'two', 'three', 'one', 'two', 'three', 'one', 'two', 'three','one', 'two', 'three','one', 'two', 'three','one', 'two', 'three',] );
          // this.list.startup();
          // this.list.resize();


          

          this.editableList = new EditableList({ 

            ListConstructor: declare( [ OnDemandList, Selection, Keyboard ], {
              className: 'select-list',

              renderRow: function(item, options){
                console.log("RENDERING: " + item.name );
                // var row = put('div.row', JSON.stringify(item) );
                var row = put('div' );
                row = put('div.row', item.name );
                // put(row, 'div', "something" );
                return row;

              },

            }),

            EditingConstructor: declare([ EditingWidget ], {
              templateString: jade.compile( '' +
                'div\n' +
                '  form( data-dojo-type="dijit/form/Form", data-dojo-attach-point="formWidget", method="POST" )\n' +
                '    .inputField( style="display:inline-block; margin-right:30px")\n' +
                //'      label( for="${id}_Name" ) Workspace name\n' +
                '      input(  id="${id}_Name", name="name", data-dojo-type="dijit/form/ValidationTextBox", style="width:10em;", maxlength="50", data-dojo-props="required:true", data-dojo-attach-point="nameWidget" )\n' +
                 '      input.formSubmit(type="submit", style="display: inline-block;",data-dojo-attach-point="buttonWidget", data-dojo-type="hotplate/hotDojoWidgets/BusyButton", label="Update")' +
                '' )(),
                startup: function(){
                  this.inherited(arguments);
                  this.nameWidget.focus();
                },
            }),

            storeName: 'categories',
            storeFields: { workspaceIdCall: globals.workspaceId },

          }, this.listNode );
         
          this.editableList.startup();
        },

        resize: function(){
          this.inherited(arguments);
          console.log('RESIZED HERE');
          // if( this.editableList ) this.editableList.resize();
        }

   });

  return Dashboard;

});

