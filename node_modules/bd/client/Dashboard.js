define([
   "dojo/_base/declare",
   "dojo/when",
   "dojo/store/Observable",
   "dojo/topic",
   "dojo/on",
   "dojo/_base/lang",
   "dojo/dom-construct",
   "dojo/dom-style",
   "dojo/dom-attr",
   "dojo/aspect",

   "dijit/_WidgetBase",
   "dijit/_TemplatedMixin",
   "dijit/_WidgetsInTemplateMixin",
   "dijit/Destroyable",
   "dijit/Dialog",
   "dijit/_OnDijitClickMixin",
   "dijit/focus",

   "dijit/layout/BorderContainer",
   "dijit/layout/StackContainer",
   "dijit/layout/TabContainer",
   "dijit/layout/ContentPane",
   'dijit/_Container',
   'dijit/layout/_ContentPaneResizeMixin',

   'dgrid/List',
   'dgrid/OnDemandList',
   "dgrid/Selection",
   "dgrid/Keyboard",
   "dgrid/util/mouse",
   'put-selector/put',

   "hotplate/hotDojoAuth/LogoutButton",
   "hotplate/hotDojoWidgetHooks/_TemplatedHooksMixin",
   "hotplate/hotDojoStores/AppStoreNotify",
   "hotplate/hotDojoWidgets/_OverlayMixin",
   "hotplate/hotDojoWidgets/EditingWidget",
   "hotplate/hotDojoCometMessages/messages",
   "hotplate/hotDojoSubmit/defaultSubmit",
   "hotplate/hotDojoWidgets/BusyButton",
   "hotplate/hotDojoStores/stores",

   "hotplate/bd/globals",
   "hotplate/bd/AccessConfig",
   "hotplate/bd/AdminConfig",
   "hotplate/bd/UserConfig",

   "hotplate/bd/AppConfigVars",

   // "app/widgets/SearchPage",

   ], function(
     declare
     , when
     , Observable
     , topic
     , on
     , lang
     , domConstruct
     , domStyle
     , domAttr
     , aspect

     , _WidgetBase
     , _TemplatedMixin
     , _WidgetsInTemplateMixin
     , Destroyable
     , Dialog
     , _OnDijitClickMixin
     , focusUtil

     , BorderContainer
     , StackContainer
     , TabContainer
     , ContentPane
     , _Container
     , _ContentPaneResizeMixin

     , List
     , OnDemandList
     , Selection
     , Keyboard
     , mouse
     , put

     , LogoutButton
     , _TemplatedHooksMixin
     , dummy
     , _OverlayMixin
     , EditingWidget
     , messages
     , ds
     , BusyButton
     , stores

     , globals
     , AccessConfig
     , AdminConfig
     , UserConfig

     , AppConfigVars

 ){


    var EditableList = declare( _WidgetBase, {

      // Internal list of rows being edited or being deleted
      _editing: {},
      _inDeletion: {},

      // Store
      storeName: '',
      store: null,
      //storeFields: {},

      listWidget: null,

      EditingConstructor: null,
      editingWidget: null,
      editingWidgetPlacement: 'inline', // It can be 'inline', 'dialog'
      multipleEditingAllowed: false,

      AddingConstructor: null,
      addingWidget: null,
      addingWidgetPlacement: 'nowhere', // 'nowhere', 'before', 'after',

      // Edit and delete buttons
      editButton: 'Edit',
      deleteButton: 'Delete',

      // Refresh parameters
      refreshOnSubmit: false,

      constructor: function( params ){
        // this.store = stores( params.storeName, params.storeFields );
        this.editing = {};
      },

      // Proxy method for listwidget.row()
      row: function( p ){
        return this.listWidget.row( p );
      },


      buildRendering: function(){

        var self = this;

        this.listWidget = new this.ListConstructor( { store: this.store } );

        this.domNode = put( 'div' );

        // if( this.addingWidgetPlacement === 'before' && this.addingWidget ) put( this.domNode, this.addingWidget );
        put( this.domNode, this.listWidget.domNode );
        // if( this.addingWidgetPlacement === 'after' && this.addingWidget ) put( this.domNode, this.addingWidget );

        this.inherited(arguments); 

      },

      postCreate: function(){

        this.inherited(arguments); 
        var self = this;       


        // Create the adding widget
        if( self.AddingConstructor ){

          // Create an editing widget using the passed constructor. However,
          // it will set storeName, storeFields and recordId
          self.addingWidget = new self.AddingConstructor({
            storeName: self.storeName,
            store: self.store,
            //storeFields: self.storeFields,
          });

         //  put( self.domNode, ">", self.addingWidget.domNode );
         // self.addingWidget.startup();


          // Place the adding widget in the right spot
          put( self.domNode, ">", self.addingWidget.domNode );

          self.addingWidget.startup();

          // if self.refreshOnSubmit is set, then it will refresh the
          // list
          if( self.refreshOnSubmit ){
            self.own( self.addingWidget.on('successfulsubmit', function( e ){
              self.listWidget.refresh();
            }) );
          }

        }


        // Turn self.[edit|delete]Button into widgets (busyButtons) if
        // they were passed as strings
        if( typeof( self.editButton ) === 'string' ){
          self.editButton = new BusyButton({
            label: self.editButton
          });
          self.editButton.startup();
        }

        if( typeof( self.deleteButton ) === 'string' ){
          self.deleteButton = new BusyButton({
            label: self.deleteButton
          });
          self.deleteButton.startup();
        }

        // Wire the button's clicks to the right action
        if( self.editButton ){
          self.editButton.on('click', function(e){
            var row = self.row( e );         
            var row = self.row( e );         
            put( row.element, self.editButton.domNode, '!' );
            put( row.element, self.deleteButton.domNode, '!' );
            self._editRow( row );
          });
        }
        if( self.deleteButton ){
          self.deleteButton.on('click', function(e){

            var row = self.row( e );         

            put( row.element, self.editButton.domNode, '!' );
            put( row.element, self.deleteButton.domNode, '!' );
            var cover = put( row.element, 'div.overlay' );
            domStyle.set( cover, 'position', 'absolute' );
            domStyle.set( cover, 'top', '0' );
            domStyle.set( cover, 'bottom', '0' );
            domStyle.set( cover, 'left', '0' );
            domStyle.set( cover, 'right', '0' );
            domStyle.set( cover, 'z-indez', '99' );
            domStyle.set( cover, 'background', 'rgba(0,0,0,0.32)' );
            domStyle.set( cover, 'display', 'block' );
            domStyle.set( row.element, 'pointer-events', 'none' );
            self._inDeletion[ row.id ] = true;
          
            self._deleteRow( row ).then(
              function( res ){
                console.log("IN RES");
                
              },
              function( err ){
                console.log("IN ERR");
                self._inDeletion[ row.id ] = false;
                put( row.element, cover, '!' );
                domStyle.set( row.element, 'pointer-events', 'all' );
              }
            );
          });
        }


        // Pressing Enter will trigger editing
        self.listWidget.on( 'keypress' , function( e ){
          var row = self.row( e );
          R2 = row;
          if( e.charCode == 13 && ! self._inDeletion[ row.id ] ){
            var row = self.row( e );
            self._editRow( row );
          } 
        }),

        // Double-click will trigger editing 
        self.listWidget.on('.dgrid-row:dblclick', function(e){
          var row = self.row( e );
          self._editRow( row );

        })


        // Make the edit/delete buttons appear if the mouse goes over them
        self.listWidget.on( mouse.enterRow, function(e){
          var row = self.row( e );

          // Don't show buttons if editing right now
          if( self._editing[ row.id ] ) return;

          // Don't show more buttons if a row is being edited and multipleEditingAllowed is false
          if( Object.keys( self._editing ).length > 0 && ! self.multipleEditingAllowed ) return;

          // Add the buttons if they are present
          if( self.editButton ){
            put( row.element, self.editButton.domNode );
          }
          if( self.deleteButton ){
            put( row.element, self.deleteButton.domNode );
          }
        });

        // Take the buttons out of the DOM for that row when the mouse
        // leaves
        self.listWidget.on( mouse.leaveRow, function(e){
          var row = self.row( e );

          if( self.editButton ){
            put( row.element, self.editButton.domNode, '!' );
          }
          if( self.deleteButton ){
            put( row.element, self.deleteButton.domNode, '!' );
          }
        });


        // Make sure that every row is rendered with "position: relative" as it's used
        // by inline editing and edit/delete buttons
        self.own( aspect.around( self.listWidget, 'renderRow', function( renderRow ){
          return function( object, options ){
            var r = renderRow( object, options );
            domStyle.set( r, 'position', 'relative' );
            return r;
          }
        }) );

        // Aspect to check if renderRow is called for a row that is being edited
        // IF that's the case, it will need to re-attach the editing widget's domNode
        // to it, so that it doesn't disappear (zapped by renderRow which returns a new DOM)
        if( self.editingWidgetPlacement === 'inline' ){
          self.own( aspect.around( self.listWidget, 'renderRow', function( renderRow ){

            return function( object, options ){
         
              var id = object[ self.store.idProperty ];
              if( self._editing[ id ] ){
                //console.log("RENDERING WHILE EDITING OF " + object.name );
                var r = renderRow( object, options );
                put( r, self._editing[ id ].editingWidget.domNode );
                return r;
              } else {
                //console.log("CLEAN RENDERING OF " + object.name );
                
                return renderRow( object, options );
              }
            }

          }) );
        }

      },


      startup: function(){
        this.inherited(arguments); 
        this.listWidget.startup();
      },

      destroy: function(){

      },


 
      // Allows editing of a row in a dialog box
      //
      _editInDialog: function( row ){
        var self = this;
        var editingWidget;

        // Create an editing widget using the passed constructor. However,
        // it will set storeName, storeFields and recordId
        editingWidget = new self.EditingConstructor({
          storeName: self.storeName,
          store: self.store,
          //storeFields: self.storeFields,
          recordId: row.id,
        });

        // if self.refreshOnSubmit is set, then it will refresh the
        // list
        if( self.refreshOnSubmit ){
          editingWidget.on('successfulsubmit', function( e ){
            self.listWidget.refresh();
          });
        }


        // Make up the dialog with editing widget, show it
        self.dialog = new Dialog({
          title: "Edit",

          // The widget was created programmatically: destroy on hiding
          hide: function(){

            // Dialog.hide() returns a promise, which resolves when
            // the hiding animation is over. 
            // First of all, get this promise...
            var p = this.inherited('hide', arguments ); // Need the name, this will be lang.mixin, not declare.safeMixin

            // Attach a new callback triggered when the animation is over:
            // the callback will destroy the widget
            p.then( lang.hitch(this, function(){
              this.destroyRecursive();
            }));

            // Return the promise, in case other calls want to
            // attach more callbacks to it
            return p;
          },

        });

        self.dialog.addChild( editingWidget );
        self.dialog.startup();
        self.dialog.show();

        editingWidget.on( 'successfulsubmit', function(){
          self.dialog.hide();
          console.log( row.element );
          focusUtil.focus( row.element );  
        });

      },

      // Allows editing of a row inline
      //
      _editInline: function( row ){
        var self = this;
        var editingWidget;

        if( self._editing[ row.id ] ) return;

        // Self._editing will be an object containing several rows
        // indexed by row.id and each row contains:
        //
        // element:        the element's domNode
        // editingWidget:  the editing widget attached to that row
        // 
        self._editing[ row.id ] = { element: row.element } ;


        // Create an editing widget using the passed constructor. However,
        // it will set storeName, storeFields and recordId
        editingWidget = new self.EditingConstructor({
          storeName: self.storeName,
          store: self.store,
          //storeFields: self.storeFields,
          recordId: row.id,
        });

        // if self.refreshOnSubmit is set, then it will refresh the
        // list
        if( self.refreshOnSubmit ){
          editingWidget.on('successfulsubmit', function( e ){
            self.listWidget.refresh();
          });
        }

        self._editing[ row.id ].editingWidget = editingWidget;

        // Give the row the class .dgrid-cell-editing
        put( row.element, ".dgrid-cell-editing");

        // Add the editing widget to the row domNode. It will have
        // absolute positioning, which means it will overlap
        // the actual row
        put( row.element, editingWidget.domNode );
        put( editingWidget.domNode, '.row-editor' );

        // Basic styles to make sure that the editing widget is positioned correctly
        domStyle.set( row.element, 'position', 'relative' );
        domStyle.set( editingWidget.domNode, 'position', 'absolute' );
        domStyle.set( editingWidget.domNode, 'top', 0 );
        domStyle.set( editingWidget.domNode, 'z-index', 20 );

        // FIXME: This should be in the CSS
        // ALSO FIX CSS in terms of forms: have two classes, one for "one-liners" and one for complex forms
        // domStyle.set( editingWidget.domNode, 'background-color', 'grey' );
        domStyle.set( editingWidget.domNode, 'background-color', '#e9f2fe' );
        domStyle.set( editingWidget.domNode, 'width', '50%' );

        // Startup and show the widget
        editingWidget.startup();
        editingWidget._onShow();

        // Escape and successful submit will close this form (properly)
        // by taking the class out, delete the self.editing entry,
        // and destroying the widget
        editingWidget.formWidget.on( 'keypress' , function( e ){
          if( e.keyCode == 27 ) closeThis(); 
        }),
        editingWidget.on( 'successfulsubmit', function(){
          closeThis();
        });

        function closeThis(){
          put( row.element, "!dgrid-cell-editing"); // Take out the extra editing class
          focusUtil.focus( self.row( row.id ).element );  
          delete self._editing[ row.id ]; // Delete the self._editing holder
          editingWidget.destroyRecursive(); // Destroy the widget
          console.log( self.row( row.id ).element );
          self.listWidget.select( row.id );
          focusUtil.focus( self.row( row.id ).element );// FIXME: Won't work
          //To test in browser: check = function() { setTimeout( function(){ console.log( LAST = F.curNode); check(); }, 3000 ) };check()
          //F = focusUtil;
          //E = self.row( row.id ).element;
          //L = self.listWidget;
          
        }
      },


      _editRow: function( row ){
        var self = this;

        if( self.multipleEditingAllowed || Object.keys( self._editing ).length < 1 ){

          if( self.editingWidgetPlacement === 'inline' ){
            self._editInline( row );
          } else {
            self._editInDialog( row );
          }
        }       
      },

      _deleteRow: function( row ){

        var self = this;

        // Try to save the values
        var promise = when( self.store.remove( row.id )) .then(
          
          function( res ){
             // alert('Deleted!');
          },
          ds.UIErrorMsg( null, null, null )
        );
        return promise;

      },

    });
 

     // Create the "login" pane, based on a normal ContentPane
     // var Dashboard = declare('hotplate/bd/Dashboard',  [_WidgetBase, _Container, _ContentPaneResizeMixin, Destroyable, _OverlayMixin, _TemplatedMixin, _WidgetsInTemplateMixin ], {
     var Dashboard = declare('hotplate/bd/Dashboard',  [ ContentPane, Destroyable, _OverlayMixin, _TemplatedMixin, _WidgetsInTemplateMixin ], {

      widgetsInTemplate: true,

      templateString: jade.compile('' +
        'div\n' +
        '  div( data-dojo-attach-point="listNode")\n'+
        '')(),


        postCreate:function(){
          var that = this, q;

          this.inherited(arguments);

          var escapeHTML = function( str ) {
            var div  = document.createElement( 'div' );
            var text = document.createTextNode( str );
            div.appendChild( text );
            return div.innerHTML;
          };

        },

        startup: function(){
          this.inherited(arguments);
          var counter = 0;


          this.editableList = new EditableList({ 

            refreshOnSubmit: false,

            className: 'MERC-widget',
            ListConstructor: declare( [ OnDemandList, Selection, Keyboard ], {

              renderRow: function(object, options){
                var row = put('div.row', object.name + ' ' + object._id + ' ' + counter++ );
                return row;
              },

							postCreate: function(){
                self = this;
								this.inherited(arguments);
								// this.set( 'queryOptions',{ before: { _id: '514aba99849418630e0001b8' }  } );
								this.set( 'queryOptions',{ placeNew: 'last' } );
								// this.set( 'queryOptions', { placeNew: 'none', sort: [ { attribute:'name' } ]  } );
								// this.set( 'queryOptions',{ placeNew: 'last' } );
								//this.set( 'queryOptions',{ before: null  } );
                // aspect.after(this, 'insertRow', function(){
                //  console.log("PPPP");
                //}, true );

							}

            }),

            EditingConstructor: declare([ EditingWidget ], {
              templateString: jade.compile( '' +
                'div\n' +
                '  div.inlineform\n' +
                '    form( data-dojo-type="dijit/form/Form", data-dojo-attach-point="formWidget", method="POST" )\n' +
                '      .inputField( style="display:inline-block; margin-right:30px")\n' +
                //'      label( for="${id}_Name" ) Workspace name\n' +
                '        input(  id="${id}_Name", name="name", data-dojo-type="dijit/form/ValidationTextBox", style="width:10em;", maxlength="50", data-dojo-props="required:true", data-dojo-attach-point="nameWidget" )\n' +
                 '        input.formSubmit(type="submit", style="display: inline-block;",data-dojo-attach-point="buttonWidget", data-dojo-type="hotplate/hotDojoWidgets/BusyButton", label="Update")' +
                '' )(),
                startup: function(){
                  this.inherited(arguments);
                  this.nameWidget.focus();
                },

            }),

            AddingConstructor: declare([ EditingWidget ], {
              templateString: jade.compile( '' +
                'div\n' +
                '  div.inlineform\n' +
                '    form( data-dojo-type="dijit/form/Form", data-dojo-attach-point="formWidget", method="POST" )\n' +
                '      .inputField( style="display:inline-block; margin-right:30px")\n' +
                //'      label( for="${id}_Name" ) Workspace name\n' +
                '        input(  id="${id}_Name", name="name", data-dojo-type="dijit/form/ValidationTextBox", style="width:10em;", maxlength="50", data-dojo-props="required:true", data-dojo-attach-point="nameWidget" )\n' +
                 '        input.formSubmit(type="submit", style="display: inline-block;",data-dojo-attach-point="buttonWidget", data-dojo-type="hotplate/hotDojoWidgets/BusyButton", label="Add")' +
                '' )(),
                startup: function(){
                  this.inherited(arguments);
                  //this.nameWidget.focus();
                },
                resetOnSuccess: true,

            }),


            storeName: 'categories',
            //storeFields: { workspaceIdCall: globals.workspaceId },
            store: stores( 'categories', { workspaceIdCall: globals.workspaceId } ),
            editingWidgetPlacement: 'inline',
            multipleEditingAllowed: false,

            editButton: 'edit',
            deleteButton: 'delete',


          }, this.listNode );
        
          this.editableList.startup();
        },

        resize: function(){
          this.inherited(arguments);
          console.log('RESIZED HERE');
          // if( this.editableList ) this.editableList.resize();
        }

   });

  return Dashboard;

});

