define( [
  "dojo/_base/declare"
, "dojo/topic"

, "hotplate/hotClientDojo/stores/stores"


], function(
  declare
, topic

, stores

){

  topic.subscribe( 'hotplate/hotClientDojo/newStore', function( storeName, store ){

    switch( storeName ){
      case 'workspacesContactsEmails':
      case 'workspacesContactsAddresses':
      case 'workspacesContactsPhoneNumbers':

        // Workout the field name in 
        var mainFieldName = storeName === 'workspacesContactsEmails' ? 'mainEmailId' : ( storeName === 'workspacesContactsPhoneNumbers' ? 'mainPhoneNumberId' : 'mainAddressId'); 

        store.on( 'add,update,delete', function( event ){


          var first = store.memCache.data[ 0 ];

          // There is no record, end of story.
          if( ! first ) return;

          // Get the contact from the store
          var contactsStore = stores( 'workspacesContacts', { workspaceId: event.target.workspaceId });
          var contact = contactsStore.memCache.getSync( event.target.contactId );

          // If the contact isn't in the cache, that's it: nothing to do
          // This is very possible! 
          if( ! contact ) return;

          // If the first item in the store's cache is NOT the contact's mainEmailId, then make it so
          // Also emit an "update" event on the contact, since it has "changed"
          if( typeof contact[ mainFieldName ] !== 'undefined' && contact[ mainFieldName ]!== first.id ){

            contact[ mainFieldName ] = first.id;
            contact._children[ mainFieldName ] = first;
            // TODO: if I don't want the children to have _children set, I need to create a copy
            // of the object and then assign it. But it would be wasteful. Decide whether it's worth it
            //contact._children[ mainFieldName ]._children = {}; // Can't do this, or the main obj's _children will get zapped
            contactsStore.memCache.putSync( contact );

            contactsStore.emit( 'update', { keepForm: true, target: contact, targetId: contact.id, doNotUpdateParentsCache: true } );
          }          
        });
      break;

    } // switch
  })

  return {};

});

